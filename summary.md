# Изучаю Python

## Раздел 3. Переменные и типы

### REPL

Сегодня я начинаю изучение Python с простейших математических операций в так называемом REPL-режиме (Read, Execute,
Print, Loop). Этот режим позволяет вводить команды которые моментально выполняются и выводят результат. Повторяется
этот процесс до тех пор, пока вы не завершите сессию. REPL идеально подходит для обучения, тестирования кода и
выполнения небольших вычислений без создания новых файлов.

Для начала работы:

1. Убеждаюсь, что Python установлен, проверив его версию в терминале.
2. Открываю терминал в Windows 11 и ввожу команду "py", чтобы войти в REPL.

В этом режиме можно выполнять простые математические операции:

- Например, введя `1 + 2`, получаю результат `3`.
- при делении `10 / 2` получаю `5.0`.

Так же возможен вызов встроенных функцийй, например `print("Привет")` выведет текст "Привет".

Несмотря на ограниченное исиользорвание REPL в больших проектах, он полезен для изучения базовых операций и встроенных
функций Python.

Чтобы выйти из REPL, нужно выполнить команду `exit()`. Ctrl+C не завершит сессию, поэтому функция `exit()` необходима
для выхода.

Поняв основы работы Python в REPL, перейду к созданию первого файла с кодом, где рассмотрю переменные и другие
концепции.

### Создание первого скрипта

Итак, кратко подведу итоги по созданию первого скрипта на Python:

1. **Создание проекта**:
   - Создание новой папки для проекта. Это можно сделать через файловый менеджер или через терминал командой `mkdir`.
   - Открытие папки в Visual Studio Code.
2. **Создание Python-файла**:
   - Внутри папки создал новый файл с расширением `.py`, например `hello.py`. Это обозначает, что файл является
     Python-скриптом.
3. **Написание кода**:
   - В файле `hello.py` написал код вызова функции `print`, чтобы вывести текст на экран.
4. **Запуск скрипта**:
   - Открыл терминал и выполнил команду `py hello.py` для запуск скрипта.
5. **Проверка результата**:
   - Убедился, что в терминале появилось слово "Привет", что означает успешное выполнение скрипта.

### Переменные в Python

**Что такое переменные и зачем они нужны**

- **Переменная** - это контейнер, который хранит данные, которые можно использовать и изменять в коде.
- Она позволяет сохранить значение, например, число или строку, которое можно использовать многократно.

**Обхявление переменных**

- В Python нет специальных операторов для объявления переменных, как в некоторых других языках.
- Объхявление происходит присвоением значения переменной.

```
py
num = 5
```

**Изменение значений переменных**

- В любую переменную можно поместить новые данные.

```
py
num = 7 # теперь переменная 'num' содержит значение 7
```

**Динамическое изменение типа данных**

- Переменные в Python могут менять свой тип данных динамически.

```
py
num = "привет" # теперь 'num' содержит строку
```

**Правила именования переменных**

- Имя переменной может содержать буквы, цифры и символы подчеркивания, но не может начиинатся с цифры.
- Используем читаемые имена, например, `my_number`.
- Популярные стили: snake*case* (*my*num), PfscalCase(MyNum), CAPS*LOCK* (_MYNUM_) для констант,
  число может быть только в конце (*my*num1).

**Ошибки при неправильном именовании**

-Переменная не может начинаться с цифры, содержать дефисы, пробелы и спецсимволы.

```
py
2num = 5 # ошибка
my-num = 3 # ошибка
my num = 4 # ошибка
```

**Комментарии**

- Комментарии начинаются с символа `#` и игнорируются интерпритатором.

```
py
# Это комментарий
num = 5 # это тоже комментарий
```

Использование переменных как контейнеров для значений, чтобы управлять данными и логикой в коде более эффективно.

### Название переменных

Именование переменных и стиль кода

1. Значение осмысленных названий:
   - Переменные должны иметь понятные, описательные имена.
   - это облегчает понимание и поддержку кода.
2. Пример неверного и верного именования:
   - Вместо a использовать user_age для обозначения возраста пользователя.
3. Стиль именования в Python:
   - Стандарт: lowercacs с нижним подчеркиванием (например, user_age).
   - CamelCase нежелателен, хотя и допустим.
4. Именование функций:
   - Следует аналогичным пправилам, как и для переменных.
   - Название должно отражать функциональность (напримпер, is_admin для логического названия).
5. Типы данных и префиксы:
   - Для логических переменных (boolean) часто используются префиксы is, has.
6. Присвоение множественных значений:
   - Можно присваивать несколько значений одновременно (например, a, b = 1, 4).
   - Использовать только для связанных переменных, например, координаты x и y.
7. Пример хорошей практики:
   - Понятные и описательные названия, чтобы улучшить читаемость и поддержку кода.

### Типы

#### Простейшие типы переменных:

1. **Строки** - текстовые данные.
2. **Числа**:
   - Целые числа (`int`)
   - Числа с плавающей точкой (`float`)
   - Комплексные числа (детально не рассматривались)
3. **Булевые значения** - `True` или `False`

#### Функция `type`:

- Функция `type` используется для определения текущего типа переменной.
- Пример: `type(user.age)` возвращает тип, связанный с `user.age`.

#### Динамическая типизация:

- В Python переменные типизируются динамически; первый присовенный тип значений определяет тип перпеменной.
- Переменная может изменять свой тип при присвоении ей новых значений другого типа.

#### Примеры:

- `user.age = 18` определяет `int`.
- `user.age = "18"` изменяет тип переменной на `str`.

#### Особенности:

- Числа с плавающей точкой (`float`) обозначаются через точку (нопример, `salary = 100.50`).
- Операции между различными числовыми типами выполняются без ошибок,
  итоговые данные приводятся к наиболее подходящему типу (например, результатом сложения int и float будет float).

#### Boolean:

- Булевое значение может быть результатом логического выражения (`10 > 1` дает `True`).
- Слова `True` и `False` пишутся с заглавной буквы вначале.

### Преобразование типов

1. **Автоматическое преобразование типов**:
   - Python может автоматически преобразовывать некоторые совместимые типы, нгапример, int и float.
   - Однако, попытка сложить разные типы, как строку и число, вызовет ошибку.
2. **Явное преобразование типов**:
   - Для преобразования типов используется функция-конструктор типов, например, int(), float(), str(), bool().
   - При преобразовании float в int дробная часть отбрасывается.
   - При неверном преобразовании типов, как строка 'd' в int, возникает ошибка.
3. **Настройка IDE для роверки типов**:
   - в Visual Studio Code через PyLens с режимом "Strict" помогает выявлять ошибки на этапе написания кода.
   - Строгий режим проверки типов позволяет IDE уведомлять о несоответствиях, предотвращая их возникновение на этапе
     выполнения программы.
4. **Преобразование чисел и строк для конкатенации**:
   - Для конкатенации строки и числа необходимо явно преобразовывать число в строку.
   - Это можно сделать с помощью str(), чтобы избежать ошибок на этапе выполнения.
5. **Правила преобразования к boolean**:
   - Для bool() любое значение, кроме нуля и пустой строки, будет интерпретироваться как True.

Рекомендация: всегда включать строгую проверку типов в IDE
и следить за соотвествием типов даннных при написании кода для профессионального подхода к разработке на Python.

### Задание типов

В данной лекции я узнал использование подсказок типов (type hints) в языке программирования Python.

1. **Поведение типов**:
   - Python автоматически определяет тип переменной на основе присваиваемого значения.
   - Например, переменная `x`, которой было присвоено значение целого числа, будет иметь тип `int`.
2. **Изменение типа**:
   - При присваивании нового значения, например, `float` или `str`, тип переменной изменится соответственно.
   - Если попробовать выполнить не совместимые операции между различными типами, возникает ошибка.
3. **Использование type hints**:
   - Чтобы строго определить допустимый тип, использутеся синтаксис `переменная: тип`.
   - Например, `x: int` - указыввает, что `x` должна содержать только `int` значения.
   - Это позволяет избекать ошибок при использовании переменной не по назначению, но не припятствует запуску кода с
     неверным типом в `runtime`.
4. **Янове объявление**:
   - Type hints могут использоваться для предварительного объявления переменных без присваивания конкретного
     значения. Например, `a: int`.
   - Это полезно, когда необходимо заранее сообщить, какие типы ожидаются в будущем.
5. **Практическое применение**:
   - Type hints важны при написании функций и классов, давая возможность явно описывать ожидаемые типы аргументов и
     возвращаемое значение.

### Константы

Константы в Python:

1. **Определение и синтаксис**:
   - В Python нет специального синтаксиса для констант.
   - Константы обозначаются с помощью заглавных бкув (например, `TIME_IN_VILLISECONDS = 1000`).
   - Это условная практика, котороая сигнализирует другим разраотчикам, что значение не должно имзеняться.
2. **Отличия от переменных**:
   - Константы выделяются заглавными буквами, в отличие от переменных с обычными строчным буквами.
   - Переменные могут менять свои значения, тогда как константы предназначены для неизменных значений.
3. **Проверка в IDE**:
   - Средства рзработки (IDE) могут предупреждать о попытке переприсвоения константы.
   - Однако в самом рантайме Python не препятствует изменению значений переменной, обозначенной как константа.
4. **Примеры использования**:
   - Константы часто представяют общепринятые значеения, такие как число PI, скорость света...
   - Они могут включать бизнес-логики, например, количество бонусов за регистрацию.
5. **Наименование**:
   - Константы должны иметь удобочитаемые имена, описывающие их назначение (например, `BONES_POINTS_FOR_REGISTRATION`).
6. **Практика использования**:
   - Соблюдение условностей помогают структуиросвать и поддерживать код.
   - Конвенция использования констант улучшает понимание кода другими разработчиками.

## Раздел 4. Простые операции

### Арифметические операторы

В этой лекции рассмотрены основные операторы в языке Python,
которые используюстя для выполнения математических операций:

1. **Арифметические операторы**:
   - **Сложение** (+): `5 + 7` даст нам 12.
   - **Вычитание** (-): `10 - 3` даст 7.
   - **Умножение** (_): `10 _ 4` даст 40.
   - **Деление** (/): `10 / 2` даст 5.0.
2. **Оператор остатка от деления (modulus, %)**:
   - `5 % 2` даст 1, поскольку делится на 2 с остатком 1.
3. **Деление без остатка**:
   - Исользуется оператор `//`. `7 // 2` даст 3, так как 7 делится на 2 всего три зара, без учета остатка.
4. **Возведение в степень**:
   - Используется оператор `**`. `2 ** 5` даст 32, так как это 2 в пятой степени.
5. **Взятие корня**:
   - Также используется оператор `**`. `9 ** 0.5` даст 3.0, что соответствует квадратному корню из 9.

Эти базовые операторы помогут выполнять основные математические операции в Python.
Для более сложных вычислений, таких как тригонометрические функции,
можно использовать специаьные библиотеки.

### Операторы присвоения

В этом уроке изучены операторы пррисвоения в программировании и их использование.

1. **Осовной оператор присвоения (=)**: Он используется для присваивания значения переменной:
   значение справа присваивается переменной слева.
2. **Короткие записи операторов присвоения**:
   - `+=`: увеличивает переменную на заданное колисество. Например, `a +=5` аналогично `a = a + 5`.
   - `-=`: уменьшает переменную на заданное количество.
   - `*=`: умножает переменную на заданное количество.
   - `/=`: делит переменную на заданное количество, результат певращает в float.
   - `%=`: присваивает остаток от деления.
   - Эти операции позволяют сократить запись арифметических операций и присвоения.
3. **Порядок оператовор**: Оператор присвоения имеет более низкий приоритет, чем арифметические операции,
   поэтому сначала выполняются математическуие выисления, а затем уже присвоение.
4. **Дополнительные операторы присвоения**:
   - **Поибтовые операции**: Существют также сокращенные записи для побитовых операций, например `|=`,
     но их использование требует понимания булевой логики и двоичного представления чисел.
5. **Специфичное использование внутри функции**: Можно создаваать переменные прямо в присваивании внутри функции,
   что упрощает код, если переменная используется только в контексте этой функции.

Это основные моменты, связанные с операторами присвоения, ктотрые делают код более лаконичным и удобочитаемым.

### Операторы сравнения

**Операторы присваивания и сравнения**:

1. Однго равно (`=`) используется для присваивания занчения переменной.
2. Двойное равно(`==`) используется для сравнения значений на равенство.
3. **Практика с переменными**:
   - Создаем переменные `a = 10` и `b = 9`.
   - Сравниваем их `a` == `b` вернет `False`, так как значения не равны.
4. **Булевые значения**:
   - `True` и `False` записываются с большой буквы.
5. **Операторы неравенства**:
   - Проверка на неравенство: `a != b` вернет `True`, если значения не равны.
   - Проверка на больше: `a > b` вернет `True`, если `a` больше `b`.
   - Проверка на меньше: `a < b` вернет `True`, если `a` меньше `b`.
6. **Сложные сравнения**:
   - `a >= b` для проверки больше или равно.
   - `a <= b` для проверки меньше или равно.
7. **Переменные типа `bool`**:
   - Результаты сравнений можно присваивать переменным типа `bool` для дальнейшего использования.
8. **Вывод**:
   - Операторы сравнения возвращают значения типа `bool`: `True` или `False`.
   - Операторы сравнения позволяют гибко и точно работать с условиями в коде.

### Булева логика

**Введение**

Булева логика необходима для понимания операторов в программировании.
Если вы с ней не знакомы, важно ознакомиться с базовыми концепциями,
чтобы эффективно использовать условия в коде.

**Основные Операторы**

1. **И (AND)**
   - Оператор "И" требует, чтобы оба условия были истинными для получения истинного общего результата.
   - Например, выражение "A и B" будет истинным, только если "A" истинное, и "B" истинное.
2. **Или (OR)**
   - Оператор "Или" определяет истинность, если хотя бы одно из условий истинно.
   - Если "A" истинно или "B" истинно (или оба), общее выражение также будет истинным.
3. **Не (NOT)**
   - Оператор "Не" инверсирует значение услоовия: превращает истину в ложь и ложь в истину.
   - Например, "не A" означает, что если "A" истинно, то "не A" будет ложным, и наоборот.

**Примеры использования**

- **Для оператора И**:

  - Если (A > 0) и (A < 10), для (A = 5) выражение истинно, но для (A = 12) - ложно, так как (A < 10) не выполняется.

- **Для оператора Или**:

  - Если (A > 10) или (A < 0), то для (A = 20) или (A = -5) выражение истинно, а для (A = 5) - ложно,
    так как оба условия не выполняются.

- **Для оператора Не**:
  - Если (A > 10), то "не A > 10" равняется (A \leq 10), представляя все, что меньше или равно 10.

### Логические операторы

На этом уроке я научился применять булеву логику в Python с использованием логических операторов: `and`, `or` и `not`.

1. **Операторы в Python**:
   - В Python операторы логики (`and`, `or`, `not`) напрямую соответствуют их английским названиям,
     что упрощает их использование.
   - Они более читаемы по сравнению с другими языками пронраммирования, такими как JavaScript или Golang.
2. **Примеры использования**:
   - **Оператор `and`**:
     - Служит для проверки, чтобы оба условия были истинны.
     - Пример: Пусть `x = 5`. Проверка `x > 0 and x < 10` вернет `True`, так как оба условия выполняются.
   - **Оператор `or`**:
     - Позволяет проверять, чтобы хотя бы одно из условий было истинно.
     - Пример: Для `x = 5`, выражение `x < 0 or x >= 10` вернет `False`, потому что ни одно из условий не выполняется.
   - **Оператор `not`**:
     - Инвертирует логическое значение.
     - Пример: `not(x < 0 or x >= 10)` для `x = 5` вернет `True`, потому что внутри скобок значение `False`.
3. **Вазность порядка операторов**:
   - Важен порядок выполнения операторов. Python сначала выыполняет операторы сравнения (например, `>`, `<`),
     затем борьбу между `and` и `or`, и только после этого выполняется объединение с `not`.
   - Скобки могут использоваться для изменения стандартного порядка выполнения.

### Порядок операторов

В данной лекции я рассмотрел понятие порядка выполнения операторов
и его вазность в вычислениях.
Основные моменты:

1. **Определение**:
   - Порядок выполнения операторов определяет последовательность, в которой вычисляются части выражения
   - Это помогает избежать некорректных вычислений при сложных выражениях.
2. **Приоритет операторов**:
   - Операторы имеют различные уровни приоритета,
     от самого высокого к самому низкому:
     1. эспонентация;
     2. умножение и деление;
     3. сложение и вычитание;
     4. сравнение (больше, меньше, равно);
     5. логические операторы (NOT, AND, OR).
3. **Пример последовательного решения**:
   - Рассматривались примеры, где последовательно применяются операторы в зависимости от их приоритета.
   - Например, вычисление для выражения: (3 \times 4 - 2). Сначала умножение, затем вычитание.
4. **Регулирование порядка**:
   - Для изменения стандартного проядка выполнения операторов используются скобки.
   - Скобки позволяют задать приоритет выполнения операций по желаниям программиста.
5. **Практическая значимость**:
   - Правильное понимание порядка позволяет избежать ошибок в вычислениях.
   - Возможность использования скобок для изменения порядка дает гибкость в написании кода.

### Упражнение - проверка возраста

В этом упражнении мы создали простую прграмму,
которая примимает ввод от пользователя
и оценивает возможность его трудоустройства на долджность бармена на основании возраста.

1. **Получение ввода пользователя**:
   - Использован `input()` для запроса возраста.
   - Пример ввода: `h = input("Введите возраст: ")`.
2. **Преобразование типа**:
   - Поскольку `input()` возвращает строку, преобразовываем его в целое число.
   - Используя `int(h)` для преобразования и сохранения в новой переменной, например, `h_int`.
3. **Логические условия и вывод**:
   - Проверяем возраст: он должен быть больше 18 и меньше 50.
   - Используем логическое выражение: `is_hireable = (h_int > 18) and (h_int < 50)`.
4. **Вывод результата**:
   - Программа должна вывести `True`, если возраст соответствует условиям, и `False`, если нет.
   - Пример вывода: `print(is_hireable)`.
5. **Проверка работы**:
   - Введите разные значения возаста и убедитесь, что программа правильно оценивает каждый из них.
   - Пример работы? ввод 20 даст `True`, а 16 - `False`.

Дополнительно, в коде нет проверки на нечисловой ввод.
Это может вызвать ошибку,
но мы не сосредотачиваемся на этом в данном упражнении.

## Раздел 5. Управление потоком

### if else

1. **Управление потоком**:
   - Начинаю изучение управления потоком в программировании.
   - Использую условия (IF, ELSE) для выполнения различных веток кода в зависимости от условий.
2. **Практический пример**:
   - Условие: разрешение доступа на сайт по возрасту пользователя.
   - Код проверяет, больше ли возраст 18 лет.
3. **Условия IF и ELSE**:
   - Оператор IF используется для проверки условия, например, `age >= 18`.
   - Если условие TRUE, выполняется связанный блок кода.
   - ELSE используется для выполнения кода, если условие FALSE.
4. **Отступы в Python**:
   - В Python нет скобок для обозначения блоков кода.
   - Используются отступы для определения блока кода, принадлежащего условию или циклу.
   - Отступы важны для читаемости и корректности кода.
5. **Пример кода**:
   - Сначала преобразуем ввод возраста в `int`.
   - Используем IF для проверки условия и осуществления необходимых действий.
   - ELSE для обработки случаев, когда условие не выполнено.
6. **Дополнительные условия**:
   - Возможность добавления несколькиз условий, комбенации проверок.
   - Пример: возраст более 18 и менее 50 лет.
7. **Вывод результата**:
   - Пример захватывает возможность изменения потока кода в зависимости от ввода данных.

### Отступы и PEP-8

1. **PEP-8: Что это?**
   - PEP-8: Style Guide для Python, который предлгает стандарты для написания кода.
   - Влючает рекомендации по наимпенованию переменных, структурированию кода, комментированию и другим аспектам.
2. **Фокус на Отступы (Indentation)**
   - Рекомендуемый отступ: 4 пробела.
   - Допустимо использование отступов по табуляции для старого кода, но для нового рекомендуется пробелы.
   - Важно: Каждое слово или фукнция должны иметь консистентные отступы (либо все 4 пробела), либо все табуляции.
3. **Практические настройки в Редакторе**
   - Настройки в редакторе помогают автоматически оформлять код по PEP-8.
   - Параметры для насстройки:
     - `editor.detectIndentation`: false (игнорировать текущие настройки файла).
     - `editor.indertSpaces`: true (вставлять пробелы вместо табуляции).
     - `editor.tabSize`: 4 (число пробелов при нажатии клавиши Tab).
4. **Автоматическое форматирование**
   - Использование функции автосохранения с форматированием (`format onSave`)
     для автоматической корректировки отступов.

Таким образом, PEP-8 настоятельно рекомендует использовать 4 пробела длдя отступов в Python, и его настройки в
редакторе могут помочь поддерживать эти стандарты автоматически.

### elif

Сегдня я рассмотрел, как улучшить читаемасть и удобство кода при проверке нескольких условий
с помщью конструкций IF, ELSEIF и ELSE.

1. **Проблема вложенных условий**:
   - Вложенные конструкции ELSEIF могут быть сложными и нечитабельными.
   - Например, при проверке возраста:
     - Если младше 18, печатаем "вам меньше 18 лет".
     - Если младше 50, но не младше 18, печатаем "вам от 18 до 50 лет".
     - Иначе печатаем "вам больше 50 лет".
2. **Использование ELSEIF (или ELIF)**:
   - Предлагается использовать оператор ELSEIF (в некоторых языках ELLIF), чтобы упростить код.
   - Оператор позволяет куазывать промежуточные условия без вложенности.
3. **Пример кода**:
   ```
   py
   if age < 18:
       print("Вам меньше 18 лет.")
   elif age < 50:
       print("Вам от 18 до 50 лет.")
   else:
       print("Вам больше 50 лет.")
   ```
   - Этот код проще и понятнее, чем использование вложенных IF.
4. **Проверка кода**:
   - Вводим различные значения для возраста: 16, 20, 60.
   - Код корректно обрабатывает и выводит соответствующие сообщения.
5. **Вывод**:
   - Конструкция IF, ELELSE, ELSE удобна для небольшого количества условий.
   - Она обеспечивает простоту и читабельность кода.
   - Для большего количества вариантов можно рассмотреть другие поддходы, которые я узнаю позднее.

Эта структура условий оптимизирует ваш код и повышает его читаемость.

### Тернарный оператор

#### Обзор тернарного оператора

**Тернарный оператор** - это инструмент, который упрощает запись условий и позволяет присваивать значения переменным
на основании логического условия в одну сторку.

**Пример использования**:

1. **Создание переменной**:
   - Изначально создаем переменную `is_legal_age`, которая по умоляанию будет `false`.
2. **Усложное присваивание**:
   - Если `age < 18`, переменная `is_legal_age` остается `false`.
   - Если `age >=18`, переменная `is_legal_age` становится `true`.
3. **Простая запись без else**:
   - Если переменной изначально присвоено `false`, достаточно указывать `true` только при `age >=18`.
4. **Тернарный оператор**:

   - Запись тернарным оператором:

   ```
   is_legal_age = True if age >= 18 else false;
   ```

   - Структура:
     - переменнаяч, которой присваивается значение;
     - логическое условие;
     - значение, когда условие истинно (`true`);
     - значение, когда условие ложно (`false`).

**Преимущества**:

- **Сокращает код**: Позволяет записывать условные конструкции в одну строку.
- **Простота использования**: Удобен для простых операций с присваиванием.

**Пример кода**:

```
int age = 19;
bool is_legal_age = true if age >= 18 else false;
```

Таким образом, тернарный оператор помогает сделать код более компактным и читабельным,
особенно в случаях, кодна требуется простое условное присваивание.

### Упражнение - Максимальное значение

1. **Ввод данных**:
   - Пользователь вводит три числа.
   - Все числа считываются как числа с плавающей точкой.
2. **Инициализация переменных**:
   - Пусть `a`, `b`, `c` будут вводимыми числами, преобразованными в тип `float`.
3. **Проверка условий**:
   - Чтобы найти максимальное число, используем условные операторы.
   - **Если** `a` больше либо равно `b` и `a` больше либо равно `c`, то `a` является максимальным.
   - **Иначе если** `b` больше либо равно `a` и `b` больше либо равно `c`, то `b` является максимальным.
   - **Иначе** максимальным является `c`.
4. **Вывтд результата**:
   - Печатаем наибольшее число из трех введенных.
5. **Пример тестов**:
   - Ввод: 2, 3, 4. Вывод: 4.
   - Ввод: -10, 100, 0. Вывод: 100.
   - Ввод: 1, 1, 1. Вывод: 1.
   - Ввод: 0, 0, 3. Вывод: 3.

### match case

Итак, я рассмотрел, как работать с условиями в Python, используя опператоры if-elif-else
и более современный подход match-case.

1. **Традиционный подхдод (if-elif-else)**:
   - Подходит для проверки роли пользователя, например: если роль "admin" - выводим, что пользователь администратор;
     если "manager" - менеджер, и так далее.
   - Если ни одно из условий не выполнено. Используется else как дефолтный вариант
     (например, определение роли как "уборщица").
2. **Новая конструкция match-case**:
   - Более читаемая и структурированноя альтернатива if-elif-else для случаев, когда нужно сопоставить переменную с
     несколькими значениями.
   - Match используется для переменной, которую надо сравинь. Case определяет варианты (например, 'admin', 'manager').
   - Дефолтный кейс обозначается нижним подчеркиванием (\_), что эквивалентно else.
3. **Особенности match-case**:
   - Возможность объединять несколько значений через вертикальную черту (|), например, 'admin' и 'ADMIN'.
   - Условные проверки внутри кейсов (например, добавить условие a > 0).
   - Для чисел можно использовать match с добавлением условий, хотя это може быть сложнее для восприятия.
4. **Рекомендации**:
   - Match-case лучше подходит для небольших списков значений, когда требуется структура и читаемость.
   - Для более сложных условий, вкючая дополнительные проверки, классический if-elif-else может оказаться более
     подходящим.
   - обязательно включение дефолтного кейса для обработки всех возможных значений.

### Линтер и форматер

В этой лекии обсуждаются инструменты для автоматического соблюдения стандартов форматирования кода в Python при
использовании Visual Studio Code. Рассматриваются две основные утилиты: линтеры иформатеры.

1. **Линтеры**:
   - Линтеры помогают выявлять проблемы в коде и сверять его со стандартами, такими как PEP-8.
   - Они подсвечивают ошибки, например, лишние пробелы, которые нужно убрать.
   - Популярное расширение для Visual Studio Code - Pylint.
   - После установки Pylint автоматически проверяет код на соответствие стандартам.
2. **Форматеры**:
   - Форматеры автоматически исправляют форматирование кода по стандартам.
   - Рекомендуется использовать AutoPEP8 для приведения кода в соответствие с PEP-8.
   - AutoPEP8 форматирует код автоматически при сохранении, убирая лишние пробелы и добавляя необходимые элементы,
     такие как пустые строки.
3. **Практическое применение**:
   - Установка и настройка Pylint и AutoPEP8 обеспечивают автоматическое соблюдение стандартов PEP-8.
   - Эти инструменты важны для написания качественного и чистого кода на Python с самого начала обучения.

Задача данных инструментов - облегчить процесс сблюдения стандартов PEP-8 и помочь обучающимся с первого дня писать
кода правлиьно.

### Упражнение - Лифт

**Цель**:

Разработать простое приложение лифта, которое принимает этаж от пользователя и сообщает о его предназначении.

**Шаги разрабоки**:

1. **Ввод данных**:
   - Используем `input` для получения номера этажа от пользователя.
   - Преобразуем введенные данные в целое число `int`.
2. \*\*Логическая обработка с помощью `matchCase`:
   - **Минус первый этаж (-1)**:
     - Вывести сообщение: "Подвал, здесь находится склад".
   - **Первый этаж (1)**:
     - Вывести сообщение: "Холл и ресепшн".
   - **Этажи с 2 по 9**:
     - Используем дефолтный кейс для проверки, находятся ли этажи в диапазоне 2-9.
     - **Проверка на четность**:
       - Если номер этажа четный, вывести: "Офисный этаж".
       - Если нечентый, вывести: "Жилой этаж".
   - **Десятый этаж (10)**:
     - Вывести сообщение: "Технический этаж, ход запрещен".
   - **Любое другое значение**:
     - Вывести сообщение: "Такого этажа нет".
3. **Особенности**:
   - Простая проверка с использованием `if` для определения четности этажа (делимость на 2).
   - Использование дефолтного кейса для обработки диапазноа этажей от 2 до 9.

**Проверка приложения**:

- Запустить код, введя различные номера этажей (-1, 0, 1-10, 100) и убедиться, что соответствующие сообщения выводятся
  правильно.

## Раздел 6. Списки, кортежи и работа под капотом

### Lists

На этом уроке я разобрался с последовательными типами данных на примере списков в языке программирования Python.

1. **Зачем нужны списки**?
   - Списки используются для хранения последовательности элементов, что удобно для обработки данных, например, записи
     температуры за каждый день.
   - Без списков нам пришлось бы создавать много переменных, что трудно для обаботки.
2. **Что такое списки**?
   - Списки в Python - это динамически изменяемые структуры данных с упорядоченными элементами, доступными по индексу.
     Они поддерживают хранение любых типов данных, включая смешанные типы и вложенные списки (двумерные массивы).
3. **Синтаксис списков**:
   - Списки создаются с помощью квадратных скобок, элементы разделяются запятыми.
   - Пример: `l = [10, 20, "строка", [30, 40]]`.
4. **Индексация**:
   - Индексы начинаются с нуля. Первый элемент списка доступен по индесу 0, последний по индексу `дина списка -1`.
   - Обращение к элементу: `l[index]`.
   - Ошибка при орбращении к несуществующему индексу приводит к `IndexError`.
5. **Отрицательная индексация**:
   - Позволяет обращаться к элементам с конца списка, например, `l[-1]` - последний элемент.
   - Отрицательная индексация начинается с -1, а не с -0.
6. **Изменение списков**:
   - Списки в Python мутабельны: можно менять существующие элементы, добавлять или удалять элементы.
   - Пример: `l[0] = 10` изменяет первый элемент списка.
7. **Создание пустого списка**:
   - Пустой список создается пустыми квадратными скобками: `l = []`.
8. **Типы данных**:
   - Используя `type(l)`, можно узнать тип данных объекта, в данном случяе вернет `<class 'list'>`.

### Tubles

Основные различия между списками и кортежами:

1. **Изменяемость (Mutability)**:
   - **Списки (Lists)**: Изменяемы, можно модифицировать элементы.
   - **Кортежи (Tuples)**: Неизменяемы, нельзя менять элементы напрямую.
2. **Синтаксис**:
   - **Списки**: Используют квадратные скобки `[1, 2, 3]`.
   - **Кортежи**: Используют круглые скобки `(1, 2, 3)`, которые можно даже опустить.

**Работа с длиной**:

- Функция `len()` возвращает длину списка или кортежа.
- Последний элемент можно получить как `[-1]`.

**Изменение внутренних объектов**:

- Несмотря на неизменяемость кортежа, элементы внутри могут быть изменяемыми (нопример, списки внутри кортежа).

**Конвертация**:

- Кортеж можно преобразовать в список с помощью `list()`.
- Список можно преобразовать в кортеж с помощью `tuple()`.

### Строки

#### Работа со строками как с последовательностью

1. **Основное понимание строк**:
   - Строки - это последовательости символов.
   - Тип строки в Python: `str`.
   - Можно работать со строками как со списками и кортажами (доступ к элементам по индексу).
2. **Иммутабельность строк**:
   - Строки, как и кортежи, не изменяемы.
   - Нельзя изменить элемент строки напрямую (например, `name[0] = 'u'` вызовет ошибку).
3. **Основные операции со строками**:
   - Доступ к элементам по индексу, в том числе отрицательным.
   - получение длины строки с помощью `len()`.
4. **Преобразование между типами**:
   - Строку можно преобразовывать в список или кортеж: `list(name)`, `tuple(name)`.
5. **Мультипликация строк**:
   - Умножение строк на число (например, для создания повторяющегося разделителя):
   ```
   separator = "=" * 20
   print(separator)
   ```
6. **Расширяемость операций на другие типы**:
   - Те же операции мультипликации и преобразования применимы и к спискам, и к кортежам.

Тамим образом, строки в Python - это мощный и гибкий инструмент, который можно использовать как и другие
последовательности, позволяя выполнять множество операций для обработки и манипуляции темкстом.

### Об объектах

1. **Понятие Объекта**:
   - Объект в программировании представляет собой репрезентацию чего-то из реального мира или бизнес-процессов.
   - Два ключевых свойства объекта:
     - **Состояние**: текущие характерристики объекта (например, марка и модель автомобиля).
     - **Методы**: действия, которые объект может выполнять (например, ускорение или торможение у автомобиля).
2. **Объекты в Python**:
   - В Python все элементы являются объектами, влючая примитивные типы, такие как числа и строки.
   - Это отличие Python от других языков, где обычно есть разделение между примитивными и сложными типами.
3. **Методы в Python**:
   - Объекты содержат методы, которые можно вызвать для выполнения различных операций.
   - Методы вызываются через точку (например, `строка.capitalize()`).
   - Судествуют методы с двумя подчеркиванимями (например, `__add__`), которые обеспечивают функциональность под
     капотом.
4. **Мутабельные и немутабельные объекты**:
   - Объекты могут быть мутабельными (изменяемыми) и немутабельными (неизменяемыми).
   - Пример мутабельного объекта: список.
   - Пример небумтабельного объекта: строка.
5. **Практическая демонстрация**:
   - Операции, такие как сложение, можно воспринимать как вызов метода над объектами. Например, `10 + 5` может
     проиллюстрировать внутренный вызов `10.__add__(5)`.

### Как работают переменные

В этом уроке я углубился в работу переменных Python.

1. **Создание переменной**:
   - При присвоении переменной значения (например, `a = 10`), в памяти создается объект типа `int` с этим значением.
   - Переменная `a` становится ссылкой на этот объект.
2. **Идентификатор объекта**:
   - Каждый объект в памяти имеет уникльный идентификатор, позволяющий Python отслеживать, где хранится значение.
   - Идентификатор полезен Python для управления памятью, но разработчику редко требуется его использовать.
3. **Присвоение другой переменной**:
   - Если создать переменную `b`, присвоив ей `a` (`b = a`), обе переменные ссылаются на тот же объект.
   - При изменении `a` (`a = 7`), создается новый объект, и `a` начинает указывать на него, в то время как `b` остается
     с ссылкой на старый объект.
4. **Поведение мутабельных и иммутабельных объектов**:
   - В случае с иммутабельными объектами, такими как `int`, при изменении значения создается новый объект.
   - Продробности о различиях в поведении мутабельных и иммутабельных объектов будут обсцждены в следующих лекциях.
5. **Практическая демонстрация**:
   - Использоватие функции `id()` для вывода идентификаторов переменных позволяет увидеть, как они изменяются при
     присвоении новых значений.

### Mutable и Immutable

Урок посвящен различиям между мутабельными (mutable) и немутабельными (immutable) типами данных в программировании.

1. **Immutable типы**:
   - Пример: целые числа (int), строки (string), кортежи (tuple).
   - При изменении значения создается новая область памяти.
   - Пример: `a = 10`, `b - a`. Если затем `a = 7`, то `a` и `b` указывают на разные области памяти и имеют разные
     значения.
   - Это значит, что `b` останется равным 10, даже если `a` изменится на 7.
2. **Mutable типы**:
   - Пример: списки (list).
   - Объявив список `a = [10, 0]` и присвоив `b = a`, обе переменные ссылаются на один объект.
   - Изменение списка, например `a[0] = 7`, изменяет этот общий объект.
   - После этого `a` и `b` будут иметь одинаковые значения, так как они продолжают ссылаться на один и тот же объект в
     памяти.

### Slicing

На этом уроке я узнал технику "слайсинга" в Python, которая помогает нарезать строки, списки или кортежи на подсписки
или подстроки.

1. **Основы слайсинга**:
   - Слайсинг позволяет выделить часть списка или строки, задав начальный и конечный индекс.
   - Синтаксис: `a[start:stop]`. Здесь `start` - начальный индекс (включительно), `stop` - конечныйы индекс (не включая
     его).
   - Пример: если `a` содержит `[1, 2, 3, 4, 5]`, то `a[0:3]` даст `[1, 2, 3]`.
2. **Пропуск границ**:
   - Можно пропускать начальную и конечную границы: `a[:3]` берет с нулевого до второго индекса, `a[2:]` - со второго
     до конца.
   - Если пропустиь обе границы `a[:]`, это создаст "поверхностную копию" списка.
3. **Shallow copy и его особенности**:
   - Поверхностная копия (`shallow copy`) копирует объект, но не внутренние изменяемые объекты.
   - Например, изменение вложенного списка в `a` отразиться и в копии `b`.
4. **Дополнительный параметр - шаг**:
   - Третий параметр в слейсинге задает шаг: `a[start:stop:step]`.
   - Пример: `a[0:5:2]` вернет `[1, 3, 5]` (каждый второй элемент).
   - Можно использовать отрицательный шаг для обратного обхода, например, `a[4:0:-1]` вернет `[5, 4, 3, 2]`.
5. **Применение**:
   - Слайсинг универсален и может использоваться не только со списками, но и со строками и кортежами.
   - Это мощный инструмент для копирования и выборки данных из колллекций.

### Упражнение - Палиндром

Сегодня я учился, как написать программу на Python для проверки, является ли введенное пользователем слово палиндромом.

1. **Определение палиндрома**: Слово, которое читается одинаково как слева направо, так и справа налево. Примеры:
   "Топот", "Шалаш", "Мадам". Пример, который не является палиндромом: "Привет".
2. **Цель упражнения**: Создать программу, которая получет ввод пользователя и проверяет, является ли введенное слово
   палиндромомм, используя конструкции `if`, `else` и слайсы.
3. **Шаги выполнения программы**:
   - Запросите у пользователя ввод с помощью функции `input()`.
   - Преобразуйте введенное словво в нижний регистр для корректной проверки, используя метод `lower()`.
   - Инвертируйте слово, используя слайсы `inverted_word = word[::-1]`.
   - Проверьте равенство исходного и инвертированного слова:
     - Если они равны, слово является палиндромом - выводим "Да".
     - Если не равны - выводим "Нет".

### Манипуляция со списками

Сегодня я рассмотрел манипуляции со списками: добавление, удаление и замену элементов.

1. **Замена элементов**:
   - Чтобы заменить элемент, нужно обратиться к нему по индексу.
   - Например, замена первого элемента (индекс 0) в списке `[1, 2, 3, 4, 5]` на 7: результат будет `[7, 2, 3, 4, 5]`.
   - Можно заменить сразу несколько элементов, передав новый список или кортеж. Например, замена элементов с 0-го по
     2-й индекс: передав `(7, 8)`, мы получим `[7, 8, 3, 4, 5]`.
2. **Удаление элементов**:
   - Используется ключевое слово `del`.
   - Например, удаление элемента на индексе 0 из `[1, 2, 3, 4, 5]` даст результат `[2, 3, 4, 5]`.
   - Аналогично можно удалить несколько элементов, указав диапазон индексов.
3. **Добавление элементов**:
   - **Метод** `append`: добавляет элемент в конец списка.
     - Пример: `l.append(6)` для списка `[1, 2, 3, 4, 5]` даст `[1, 2, 3, 4, 5, 6]`.
   - **Метод** `extend`: расширяет список элементами из другого списка или кортежа.
     - Пример: `l.extend([6, 7])` добавит `[6, 7]` к списку.
   - **Метод** `insert`: вставляет элемент в указанную позицию.
     - Пример: `l.insert(0, 1)` добавит `1` в начало списка (индекс 0), получим `[0, 1, 2, 3, 4, 5]`.
4. **Производительность**:
   - `append` работает быстрее, так как добавляет элемент в конец списка.
   - `insert` может быть медленнее, так как требует перемещения элементов, особенно на больших массивах.

### Копирование

1. **Основы копирования**:
   - Создание новой переменной для списка (например, `l = c`) приводит к тому, что обе переменные `c` и `l` указывают
     на одну и ту же область памяти.
   - Оператор `is` может использоваться для проверки, указывают ли две переменные на одну и ту же область памяти. Если
     `c is l`, это означает, что они идентичны по месту в памяти.
2. **Проверка равенства**:
   - Оператор `==` используется для проверки, содержат ли списки одинаковые значения, даже если они находятся в разных
     областях памяти.
3. **Shallow Copy (поверхностная копия)**:
   - Создание поверхностной копии с использованием срезов (например, `c = l[:]`) или метода `copy()` создает новый
     объект списка, но элементы внутри него все еще ссылаются на исходные обхекты в памяти.
   - При изменении элементов, которые являются вложенными объектами (например, списками внутри списка), изменения
     отразятся на обоих списках.
4. **Deep Copy (глубокая копия)**:
   - Для создания полной копии объекта, включая вложенные объекты, используется `deepcopy` из модуля `copy`. Это
     позволяет избежать ссылок на изначальные объекты внутри нового списка.

### Unpack

#### Распаквка (Unpack) в Python

Распаковка или `unpack` - это процесс извлечения элементов из списков, кортежей или строк в одельные переменные.

**Основные концепции**:

1. **Пример с кортежем**:
   - Пусть есть переменная `user`, хранящая кортеж (`name`, `age`).
   - Чтобы извлечь элементы:
   ```
   name, age = user
   ```
   - Количество переменных должно совпадать с количеством элементов в кортеже.
2. **Ошибки распаковки**:
   - Если переменных меньше: ошибка "not enough values to unpack".
   - если переменных больше: ошибка "too many values to unpack".
3. **Работа с другими структурами**:
   - **Список**: Можно распаковать так же, как и кортеж.
   - **Строка**: Можно распаковать как последовательность символов.

**Применение**:

- **Обмен значений переменных**:
  - Используя распаковку, легко поменять значения переменных `a` и `b`.
  ```
  a, b = b, a
  ```
  - Это работает благодаря оценке правой части и последующему присвоению левой.

**Важные аспекты**:

- Распаковка формирует кортеж и оценивает правую часть до присвоения переменным слева.
- Это эффективно упрощает код без использования временных переменных.

### iterable unpack

В этой лекции обсуждался "star syntax" в Python, который позволяет распаковывать элементы списка, даже если их
количство больше, чем число переменных, в которые мы собираемся из разложить.

1. **Основы Unpack**:
   - Стандартный метод распаковки предполагает, что количество переменных совпадает с количеством элементов в списке.
2. **Star Syntax**:
   - Позволяет положить "остаток" списка в одну переменную.
   - Пример: есть список `[1, 2,  3, 4, 5]`; можно распаковать первый элемент в переменную `first`, а остальнрые в -
     `rest` (`first, *rest = [1, 2, 3, 4, 5]`).
   - `rest` будет списком `[2, 3, 4, 5]`.
3. **Ограничения**:
   - Нельзя использовать `*` более одного раза в одном unpack выражении.
4. **Гибкость использования**:
   - Можнжо распаковывать элементы в несколько переменных, например, `first, second, *rest, pre_last, last`.
5. **Тип полученной переменной**:
   - `rest` всегда будет списком.

### Упражнение - Сумма границ

В данном упражнении я рассмотрел задачу по суммированию элементов списка, изучая при этом функцию SUM. Вот основные
моменты:

1. **Задача**:
   - Дан список чисел.
   - Необходимо суммировать крайние элементы (первый и последний).
   - Суммировать все остальные элементы в отдельный результат.
   - Вывести результаты в виде кортежа (сумма крайних элементов, сумма всех остальных).
2. **Использование функции SUM**:
   - SUM используется для суммирования элементов итерируемых объектов.
   - Например, SUM([1, 2, 3]) вернет 6.
3. **Реализация**:
   - Использовал распаковку списка для получения первых и последних элементов и всех остальных.
   - Пример кода:
   ```
   first, *middle, last = [10, 1, 2, 3, 5]
   fesult = (first + last, sum(middle))
   ```
   - SUM возвращает 0 при суммировании пустого списка.
4. **Особые случаи**:
   - Если в списке меньше двух элементов, обработка невозможна без модификаций, так как некому быть "last".
5. **Проверка**:
   - Протестировал разные входные данные, включая случаи с маленькими и большими списками.
   - Важно учесть, что корректная обработка списка с двумя элементами также должна быть предусмотрена.

Эти инструкции помогли решить задачу, обработать разные случаи и использовать SUM эффективно.

## Раздел 7. Строки

### Строки и Unicode

В этом разделе будет углубление в изучение строк в Python:

1. **Гомогенность строк**:
   - Строки состоят только из символов (букв, цифр, специальных символов).
   - В отличие от списков или кортежей, элементы в троках однотипны.
2. **Unicode в Python**:
   - Все строки в Python по умолчанию состоят из Unicode-символов.
   - Unicode кодировка поддерживает не только латинские буквы, но и эмоджи, буквы различных алфавитов, специальные
     символы.
3. **Работа с Unicode**:
   - Использование функции `ord()` для получения Unicode-номера символа: например, 'a' имеет номер 97.
   - Функция `chr()` позволяет преобразовать Unicode-номер обратно в символ. Нопрример, `chr(128640)` вернет эмоджи
     ракеты 🚀.
4. **Ограничения использования Unicode**:
   - Эмоджи и специальные символы могут быть частью строки, но не могут использоваться в качестве имени переменной.

### Изменение строк

На этом уроке был рассмотрен важный аспект работы со строками в Python и методы, позволяющие их модифицировать:

1. **Отличия строк от списков**: Строки состоят исключительно из символов Uicode и обладают множеством спеифичных
   методов, недоступных для списков или кортежей.
2. **Методы модификации строк**:
   - `upper()`: переводит все символы строки в верхний регистр.
   - `capitalize()`: делает первую букву строки заглавной.
   - `lower()`: переводит все символы строки в нижний регистр.
   - `strip()`: удаляет пробелы по краям строки.
   - `replace()`: заменяет указанные символы или подстроки на новые (можно заменить все вхождения).
   - `split()`: разбивает строку по указанному символуЮ, возврацая список.
3. **Multiline String**:
   - Может быть записана с использованием тройных кавычек (одинарных или двойных) и позволяет создавать строки,
     разделенные на несколько строк кода.
   - Позволяет применять все те же методы, что и однострочные строки.
   - `splitlines()`: разделяет строку на линии и возвращает список строк.

### Методы строк

На этом уроке я изучил основные методы работы со строками в программировании, которые могут быть полезны:

1. **count** - возвращает количество вхождений определенного символа в строке. Учитывает регистр.
2. **startswith и endswith** - проверяют, начинается или заканчивается строка определенной подстрокой. Возвращают
   `true` или `false`.
3. **find и rfind** - ищут индекс первого вхождения символа в строке слева направо и справа налево соответственно.
   Возвращают индекс или `-1`, если символ не найден.
4. **index и rindex** - аналогичны find и rfind, но выбрасывают ошибку, если символ не найден.
5. **isdigit, isdecimal, islower, isnumeric** и др. - позволяют проверить разные свойства строк, например, стостоит ли
   строка только из цифр, является ли она прописной и т.д. `isnumeric` помогает проверить, можно ли строку
   преобразовать в число.
6. **join** - объединяет элементы списка или кортежа в строку с заданным разделителем.

### Упражнение - Проверка email

Это упражнение посвящено проверке корректности e-mail. Основная задача - реализовать базовую проверку e-mail без
использования сложных библиотек.

1. **Цель**: Проверить корректность e-mail путем проверки структуры. Необходимо наличие локальной части, домена второго
   уровня, символа '@', точи и домена первого уровня (две буквы).
2. **Процесс проверки**:
   - Порлучить введенный e-mail от пользователя.
   - Проверить, что '@' встречается ровно один раз.
   - Разделить e-mail по '@' на две части: локальный пользователь и домен.
   - Проверить, что локальная часть не пустая.
   - Убедиться, что в домене присутствует точка.
   - Проверить, что длина домена первого уровня (после последней точки) составляет минимум две буквы.
   - Проверить, что домен второго уровня (часть до последней точки) не пустой.
3. **Дополнительные знания**:
   - Использование метода `find` и оператора `in` для поиска символов в строке.
   - Использование команды `exit()` для завершения программы.

### Интерполяция строк

Сегодня я рассмотрел три метода форматирования строк в Python: конкантенацию, метод `format` и f-строки.

1. **Конкатенация**:
   - Используем `+` для соединения строк и переменных.
   - Необходимо вручную следить за пробелами и конвертировать числа в строки.
   - Подвержено ошибкам и выглядит громоздко.
2. **Метод `format`**:
   - Используем фигурные скобки `{}` как плейсхолдеры в строке.
   - Затем применяем метод `format()`, передавая туда переменые в нужном порядке.
   - Порядок важен; для настройки можно использовать именованные аргкменты.
   - Несмотря на улучшение, метод устарел.
3. **F-строки (f-strings)**:
   - Появились с Python 3.6, отмечаются буквой `f` перед кавычками.
   - Вместо плейсхолдеров используем переменные прямо в строке, обернув их в `{}`.
   - Поддерживают встроенные выражения и форматирование вывода.
   - Наиболее читаемый и современный способ.

Вывод: f-строки - это лучший современный способ форматирования строк в Python. Они обеспечивают простоту и гибкость,
сокращая объем кода и повышая его читаемость.

### Escape Characters

1. **Понятие Escape Characters**:
   - Escape character - это специальный символ (бэкслэш), который используется для экранирования символов в строках.
2. **Экранирование кавычек**:
   - Если строка содержит кавычки, совпадающие с символами начала и конца, их можно экранировать бэкслэшем:
     - Пример: `"Привет, \"ООО Рога и копыта\""`
     - Используется для правильного отобнражения строк с кавычками внутри.
3. **Вывод бэкслэша**:
   - Чтобы вывести бэкслэш, нужно экранировать его двойным бэкслэшем: `\`.
4. **Специальные символы через escape character**:
   - **Перенос строки**: `\n`
     - Пример: `"Привет\nКак дела?"` - текст разделяется на две строки.
   - **Возврат каретки**: `\r`
     - Заменяет текст до символа каретки на новое значение.
     - Пример: `Привет\rКак дела?` выведет "Как дела?"
   - **Табуляция**: `\t`
     - Добавляет отступ или табуляцию.
     - Пример: `"Привет\tКак дела?"`.
   - **Бэкспейс**: `\b`
     - Удаляет последний символ перед ним в строке.
     - Пример: `"Привет\b!"` удалит восклицательный знак.

### Упражнение - Письмо

На этом уроке разирается создание шаблона письма с использованием f-ммтрок и переносов строк.

Основные моменты:

1. **Цель**: создать шаблон письма с приветствием, информацией о счете и просьбой об оплате.
2. **Испрользование f-строк**: Позволяет вставлять переменные внутрь строк.
   - Пример: `f"Здравствуйте, {name}!"`.
3. **Перенос строк**:
   - Вместо запятой моно использоать скобки, чтобы разделить строки для визуального удобства.
4. **Форматирование чисел**:
   - Пример форматирования числа с двумя знаками после запятой: `f"{total:.2f}"`.
5. **Умножение строк**:
   - Можно повторить строку несколько раз: `"-" * 30`.

## Раздел 8. Циклы

### Функция range

1. **Введение в циклы**
   - Циклы позволяют перебирать элементы внутри последовательностейб таких как списки или кортежи.
   - Я буду использоватеь циклы для обработки каждого элемента отдельно.
2. **Функция range**
   - **Назначение**: Создает последовательности чисел.
   - **Отилчие от списков**: Не хранит всю последовательность целиком, выдает следующий элемент по запросу.
   - **Пример**: `range(10)` генерирует число от 0 до 9 (правая граница исключается).
3. **Работа с range**
   - Преобразуем range в список для визуализации: `list(range(10))` даст `[0, 1, 2, ..., 9]`.
   - **Эффективность**: Range эффективнее по памяти для больших последовательностей, так как не хранит полный список.
   - **Тип**: `type(range)` - это объект класса Range, который хранит текущий и следующий элемент.
4. **Настройки Range**
   - **Начальное значение**: `range(5, 10)` даст числа от 5 до 9.
   - **Задание шага**:
     - `range(5, 10, 2)` будет 5, 7, 9.
     - Можно использовать отрицательный шаг, например, `range(10, 0, -1)`.
5. **Применимость range**
   - Полезен для создания числовых последовательностей, особенно в циклах.
   - Помогает в оптимизации кода при работе с большими последовательностями.

### Цикл for

#### Лекция: Циклы в Python - Цикл FOR

**Введение в циклы**

- Циклы позволяют повторять заданный код определенное количество раз.
- Они могут использоваться с различными наборами данных: списками (LIST), последовательносями (RANGE),
  кортежами (TUPLE).

**Струтура цкла FOR**

1. **Ключевые слова**: `FOR` и `IN`.
   `FOR` начинается цикл.
   `IN` указывает на коллекцию данных для итерирования.
2. **Переменная цикла**:
   - Ноходится между `FOR` и `IN`.
   - Каждый раз принимает значение из текущего элемента итерируемой коллекции.
3. **Пример цикла**:
   - Имеем числа: 1, 2, 3, 4, 5.
   - На каждой итерации переменная будет принимать последовательно значения: 1, 2, 3, 4, 5.
4. **Тело цикла**:
   - Заключенные в отступе команды, которые выполняются на каждой итерации.

**Пример работы с циклами**

- **Пример с именами**:
  - Используем список имен: Андрей, Вася, Катя.
  - Для каждого имени вывести приветствие.
  - Код:
  ```
  names = ["Андрей", "Вася", "Катя"]
  for name in names:
      print(f"Привет, {name})`
  ```
- **Пример с RANGE**:
  - Создаем диапазон от 0 до 4.
  - Выводим каждое число на экран.
  - Код:
  ```
  for num in range(5):
      print(num)
  ```

**Пример использования цикла на практике**

- **Вычисление суммы**:
  - Имеем список расходов: 10, 20, 30, 100.
  - Суммируем элемеенты списка.
  - Код:
  ```
  expenses = [10, 20, 30, 100]
  total = 0
  for expense in expenses:
      total += expense
  print(total) # Вывод: 160
  ```

**Заключение**

- Циклы являются важным инструментом для выполнения повторяющихся действий.
- В дальнейшем рассмотрю более сложные примеры и с пособы управления циклами.

### Enumerate

1. **Циклы и элементы**:
   - Ранее мы использовали циклы для работы с элементами списка, выполняя с ними операции, такие как суммирование или
     вывод в консоль.
2. **Индексы**:
   - Для некоторых задач необходимо знать не только значение элемента, но и его индекс в списке.
   - Пример: надо пометить оценки ниже 60 как "не сдал".
3. **Функция `enumerate`**:
   - Преобразует итерации: позволяет получить как значение элемента, так и его индекс.
   - Синтаксис: `for index, value in enumerate(iterable)`.
   - В нашем случае 0используется для оценки, нопримпр `gardes`.
4. **Практическое применение**:
   - Итерируемся по `grades` с использованием `enumerate`.
   - Проверяем, если оценка `grades` меньше 60, заменяем ее на "не сдал".
   - Несмотря на то, что изменяем числовой спсок на строковый, програма работает корректно.
5. **Создание нового списка**:
   - Вместо изменения существующего списка, возможно создать новый, добавляя "сдал" или "не сдал" в зависимости от
     оценки.

### Упражнение - Игра камень ножницы бумага

1. **Запрос числа раундов**:
   - Запрашиваем у пользователя, сколько раундов он хочет сыграть.
2. **Основной цикл игры**:
   - Для каждого раунда происходит следующее:
     - Пользователь делает свой выбор из "Камень", "Ножницы", "Бумага".
     - Компьютер случайным образом выбирает свой вариант с использованием библиотеки `random`.
     - Сравниваются выборы и определяетя победитель раунда.
     - Ведется подсчет очков для пользователя и компьютера.
3. **Вывод итогов игры**:
   - Подводим итогии после всех раундов: выводим общий счет и объявляем победителя или ничью.

**Как реализовать**:

- Импортируем библиотеку `random` для случайного выбора.
- Определяем функции и переменные для храниния выбора, очков и результатов.
- Используем циклы и условные конструкции для обработки логики игры.

**Рекомендации**:

- Попробуйте самостоятельно реализовать игру, используя знания о циклах, условных операторах и функции ввода `input`.
- Для случайного выбора используйте `random.choice()`.

### While

Цикл while в программировании используется, когда необходимо повторять выполнение блока кода до тех пор, пока не станет
истинным заданное условие.

1. **Синтаксис**:
   - Структура цикла начинается с ключевого слова `while`, за которым следует условие.
   - Если условие истинно (true), выполняется тело цикла.
2. **Применение**:
   - Эот цикл полезен, когда количство повторений заранее неизвестно.
   - Он удобен для игр или программ, где необходимо ожидать ввода правильного значения от пользователя или выполнения
     определенного условия.
3. **Пример использования**:
   - Игра "Угадай число", где цикл ппродолжается до тех пор, пока пользователь не введет правильное число.
   - Пример кода:
   ```
   secret_number = 7
   guess = 0
   while geuss != secret_number:
       guess = int(input("Угадайте число от 1 до 10: "))
       if guess < secret_number:
           print("Загаданное число больше")
       elif guess > secret_number:
           print("Загаданное число менье)
   print("Поздравляю, вы угадали")
   ```
4. **Предостережения**:
   - Будьте внимательны, чтобы усовие цикла действитеельно могло стать ложным, иначе цикл станет бесконечным.
   - Избегайте ситуаций, которые могут привести к бесконечным петлям, например, `while true`, без предусмотренной
     остановки.
5. **Практические советы**:
   - Всегда проверяйте корректность условия выхода из цикла.
   - Варианты бесконечного цикла допустимы, но крайне редко и только в специфицированных условиях.

Цикл `while` позволяет гибко управлять логикой повторения и широко используется в программировании для множества задач.

### Упражнение - Проверка выбора

В этом уроке я улучшил игру "Камень, Ножницы, Бумага" так, чтобы она не завершалась из-за некорректного выбора
пользователя. Вместо этого я внедрил цикл, который будет запрашивать у пользователя правильный ввод до тех пор, пока им
не будет выбран верный вариант.

1. **Проблема**: Когда пользователь вводи неправильный выбор, приложение завершает работу.
2. **Цель**: Обеспечить возможность многократного выбора до тех пор, пока не будет плучен корректный ввод.
3. **Решение**: Используею цикл `while` для проверки ввода.
   - Инициализирую переменную `user_select` пустым занчением.
   - Запускаю цикл `while`, который продолжает запрашивать ввод, пока `user_select` не будет входить в список
     допустимых значений (choices).
   - Елси пользователь вводит некорректное значение, приложение снова запрашивает выбор.
   - Цикл продолжжается до тех пор, пока пользователь не выберет "Камень", "Ножницы" или "Бумага".

В результате, игра продолжает работу даже при некорректных вводах, улачшая взаимодействие с польователем и делая
процесс выбора более гибким.

### Break continue else

В этой лекции рассматривались ключевые слова `break`, `continue` и использование `else` с циклами в Python.

**Break**

- `break` завершает выполнение цикла реньше времени по определенному условию.
- Пример: цикл `for` перебирает числа от 0 до 100 и печатает их. Если `i` превышает 10, используем `break` для
  прекращения цикла.
- `break` останавливает выполнение текущего цикла и продолжает выполнение кода после него.

**Continue**

- `continue` прекращает текущую итерацию цикла и переходит к следующей.
- Пример: цикл `for` от 1 до 10, выводит только четные числа. Если число нечетное, `continue` пропускает оставшуюся
  часть итерации.
- отличие от `break`: `continue` не завершает цикл, а только текущую итерацию, продолжая со следующей.

**Else с циклами**

- `else` с циклами `for` и `while` используется, если цикл завершился естественным образам, без использования `break`.
- Пример: если цикл завершился без вызова `break`, выполняется блок кода под `else`.
- Это полезно для проверки, завершился ли цикл по `break` или естественным образом.

### Упражнение - Проверка спама

Цель:

Научиться использовать операторы `break`, `continue` и `else` на примере простого спам-фильтра для текстовых сообщений.

**Задача**

- Проверить массив сообщений на наличие слова "СПАМ".
- Остановить проверку и вывести "Найден СПАМ", если слово обнаружено.
- Пропускать длинные сообщения (более 20 символов).
- Уведомить о завершении проверки, если спам не обнаружен.

**Алгоритм**

1. **Итерация по сообщениям**:
   - Использовать цикл `for` для перебора каждого сообщения.
2. **Проверка на "&#x73;pa&#x6D;"**:
   - Если сообщение содержит слово "СПАМ":
     - Вывести "Найден СПАМ".
     - Испольовать оператор `break` для завершения проверки.
3. **Пропуск длинных сообщений**:
   - Если длина сообщения превышает 20 символов:
     - Использовать оператор `continue` для перехода к следующему сообщению.
4. **Вывод итогов**:
   - Если цикл завершился без использования `break`, использовать `else` для вывода "Проверка завершена, СПАМ не
     найден".

**Тестирование**

- Проверить сценарии, где сообщения содержат слово "СПАМ".
- Изменить слово "СПАМ" в сообщении, чтобы убедиться, что фильтр работает правильно.
- Проверить, что длинные сообщения не обрабатываются.

### Упражнение - Таблица умножения

В этом упражнении создавалась таблица умножения от 1 до 10 с использованием вложенных циклов в Python и особенностей
функцийй print.

1. **Вложенные циклы**:
   - Для создания таблицы умножения использум два вложенных цикла for.
   - Первый цикл (i) проходит числа от 1 до 10.
   - Внутри первого цикла, второй цикл (j) также проходит числа от 1 до 10.
2. **Функция print и f-string**:
   - Используем f-string для форматированного вывода, что позволяет вставлять переменные в строку.
   - Указываем ширину для выравнивания элементов, например, 4, чтобы все 0числа занимали одинаковое место.
   - Аргумент `end` позволяет избежать автоматического перехода на новую строку, задав пустую строку вместо переноса.
3. **Форматирование вывода**:
   - После каждого элемента end задается пустой строкой, чтобы не переносить строку.
   - После заавершения внутреннего цикла (j) вставляется пустой принт для переноса строки.

## Раздел 9. Функции

### None

В данной лекции я начал изучать функции в языке программирования Python и рассмотрел специальный тип данных - None. Вот
основные моменты:

1. **Функции в Python**:
   - Функции представляют собой блоки кода, которые можно переиспользовать в приложении.
   - Приложение на Python в основном состоит из функций или методов, которые реализуют различные части
     функциональности.
2. **Понятие None**:
   - None - это спциальныый тип, обозначающий пустоту.
   - Используется в следующих случаях:
     - Конда функция ничего не вернула.
     - Для указания, что переменная пока не инициализирована.
     - Когда аргумент функции не имеет значение по умолчанию.
3. **Создание и проверка None**:
   - Переменная может быть инициализирована как None.
   - Проверка, является ли переменная None, осуществляется с помощью оператора `is` (например, `x is None`).
   - Сравнение NAN с нулем, false или пустыми строками/списками всегда дает false, так как это разные сущности.
4. **Применение None**:
   - Дает возможность обозначать, что переменная или функция пока не имеет значения или не инициализирована.
   - Позволяет избегаь ошибок, связанных с неверной интерпретацией пустых значений.

### Объявление функции

Краткое введение в функции в программировании:

1. **Определение функции**:
   - Ключевое слово `def` используется для определения функции.
   - Следует за ним имя функции (например, `add_numbers`), которое должно отражать цель функции.
2. **Аргументы функции**:
   - Указаны в круглых скобках, следуют за именем функции.
   - Функция может иметь один, несколько или неограниченное число аргументов.
   - Аргументы можно типизировать, указывая их тип после двоеточия.
3. **Тело функции**:
   - Открывается двоеточием и состоит из одной или нескольких строк кода, описывающих действия функции.
   - Ключевое слово `return` используется для возврата результата из функции.
4. **пример простой фукнции**:
   - Создание функции, которая просто печатает "Привет" без аргументов.
   - Используется путем вызова функции по имени с пустыми скобками.
5. **КЕАПМИараметры и типизация**:
   - Добавление аргументов позволяет функции принимать входные данные (Например, `username`).
   - Можно (и рекомендуетсся) указывать типы параметров и возвращаемого значения.
   - Использование f-строк для включения аргументов в выходные данные.

### Выделение функций

На этом уроке я рассмотрел, как реорганизовать код моего приложения "Камень-Ножницы-Бумага" с использованием функций.
Основные этапы декомпозиции кода:

1. **Выделение функций**: Разбиваем код на логически обособленные части. Каждая функция должна выполнять одно действие,
   что делает код более читаемым и повторно используемым.
2. **Определение этапов**:
   - Получение ввода (input) от пользователя.
   - Обработка выбора прользователем в цикле.
   - Определение и вывод результата (выбор победителя и обновление счета).
3. **Функции на примере**:
   - **select_variant()**: Функция для обработки и возвращения выбора пользователя.
   - **comute_game_result()**: Рассчитывает результат раунда и возвращает модификаторы для счета.
   - **print_result()**: Выводит итоговый счет после всех раундов.
4. **Аргументы и возвраты**: Каждой функции передаются необходимые параметры, и она возвращает значения, которые влиюят
   на логику игры.

### Область видимости

#### Область видимости в Python и порядок поиска переменных

**Область видимости (Scope)**

- **Определение**: Область кода, в которой переменная доступна для использования.

**Порядок поиска переменных (LEGB)**

1. **L (Local)**: Внутри функции.
   - Сначала Python ищет переменные внутри текущей функции.
   - Пример: Если в функции объявлена `x = 1`, то при вызове `print(x)` Python использует локальную `x`.
2. **E (Enclosing, или Замыкание)**: Вложенные функции.
   - Если переменная не найдена локально, Python ищет в функциях, охватывающих текущую функцию.
   - Это актуально для функций, возвращающих другие функции.
3. **G (Global)**: Глобальная область.
   - Если переменная отсутствует в локальной и замыкающей областях, поиск идет в глобальной.
   - Пример: Если вне функции объявлена `x = 20` и пытаемся использовать `x` в функции, будет выбрана глобальная `x`.
4. **B (Built-in)**: Встроенные функции и объекты.
   - Если переменная не найдена ни в одной из предыдущих областей, Python обращается к встроенным функциям.
   - Пример: Если переопределить `print`, Python будет искать новую реализацию, а не встроенную.

**Примеры**

- **Локальная область видимости**:

```
def my_function():
    x = 10
    print(x) # Здесь x  доступен.
my_function()
print(x) # Ошибка: x не определен в глабальной области
```

- **Глобальная область видимости**:

```
x = 20
def show():
    print(x) # Используется глобальная x
show()
```

**Важные замечания**

- **Порядок объявления переменных**: Переменные должны быть определены до их использования.
  - Например, если `show` вызывается до объявления `x`, возникнет ошибка.
- **Глобальные переменные**: Доступны в функциях после их объявления, но использование глобальных переменных может
  привести к трудноконтролируемым ошибкам.
- **Переопределение встроенных функций**:
  - Это возможно, но не рекомендуется. Например, переопределение `print()` может вызвать проблемы с выводом.

Эти принципы помогут понять, как Python ищет и использует переменные, что важно для написания корректного кода.

### Упражнене - Калькулятор

В этой лекции я создал функцию `calculate` для выполнения базовых арифметических операций. Вот основные шаги создания
функции:

1. **Определение функции**:
   - Описываем функцию как `def calculate(a: float, b: float, operation: str)`, принимающую два числаи строку-операцию.
2. **Определение логики работы**:
   - Используем конструкцию `match-case` для выбора операции (в Python 3.10 и выше).
   - Прописываем варианты:
     - Если операция "+" - возвращаем сумму `a + b`.
     - Если операция "-" - возвращаем разность `a - b`.
     - Если операция "_" - возвращаем произведение `a _ b`.
     - Если операция "/" - проверяем, что делитель `b` не равен нулю. Возвращаем частное или сообщение об ошибке
       "Ошибка: деление на ноль".
3. **Обработка неизвестной операции**:
   - Возвращаем сообщение "Неизвестная операция", если передана неподдерживаемая операция.
4. **Тестирование функции**:
   - Проводим тесты, вызывая `calculate` с различными значениями и проверяя корректность результатов.

### Docstring

Введение

- Обсудим, что такое докстринг и его важность.
- Докстринг - это строка документации, описывающая содержание функций, классов или модулей.
- Помогает разаработчикам ориентироваться в коде.

**Структура и стиль**

- Докстринг должен начинаться с заглавной буквы и не содержать точку в конце первой строки.
- Первая строка - краткое описание, далее - детальное объяснение.
- Докстринг можно структурировать с использованием `:param` и `:return`.

**Пример использования**

- Пример использования докстринга для функции, выполняющей математическую операцию.
- После добавления докстринга IDE показывает описание функции.

**Настройка поведений**

- Конфигурация файла `pylintrc` для управления предупреждениями о пропущенных докстрингах.
- Позволяет отключать ненужные сообщения, такие как C0114, через настройки `disable`.

**Рекомендации**

- Используйте докстринги для сложных функций.
- Если функция проста и ее название понятно, докстринг может быть необязателен.
- Настраивайте правила использования докстринга в зависимости от договоренностей в команде.

### Literals

Сейчас будет разговор о том, как использовать литералы для улучшения типизации в Python. Литералы помогают более точно
указывать типы переменных в коде.

1. **Что такое литерал**:
   - Литерал - это конкретное значение, например, буква илисимвол, который используется как есть.
   - Пример: если переменная `a` равна "a", то это литерал.
2. **Типизация с помощью литералов**:
   - При использовании литералов в переменных, Python IDE может подсказывать точные типы, но под капотом они остаются
     строками или числами.
   - Использование литералов помогает болееточно описывать возможные значения переменных в функциях.
3. **Пример построчного использования**:
   - Например, для функций калькулятора можно определить операцию как литерал, чтобы она принимала
     только "+", "-", "\*", "/".
4. **Как использовать библиотеку `typing`**:
   - Импортируйте `Litreal` из библиотеки `typing`.
   - Укажите возможные значения, например: `operation: Literal["+", "-", "*", "/"]`.
5. **Приемущества использования литералов**:
   - Код становится более точным и понятным.
   - Исключает возможность передачи неверного значения на этапе написания кода.
   - Облегчает поддержку и чтение кода в будущем.

### Star arguments

В этой лекции я разобрал работу с неограниченным числом аргументов в функциях с помощью использования звездочки (\*) и
параметра "args".

1. **Использование функции print()**:
   - `print()` может принимать любое количество аргументов (1, 2, 3 и более).
   - Она работает независимо от количества переданных аргументов.
2. **Аргументы функции**:
   - Чтобы функция принимала неограниченное количество аргументов, используем `*args`.
   - `args` переменная содержит все переданные аргументы в виде кортежа (tuple).
3. **Пример с функцией для среднего значения**:
   - Для расчета среднего используем `sum(args)` для суммы и `len(args)` для лдины кортежа.
   - Например, функция `avg` корректно вычисляет среднее для любого количества чисел.
4. **Другие аргументы с `*args`**:
   - Наряду с `*args` можнжо использовать другие именованные аргументы.
   - Пример функции `print_data()`, где первый аргумент - `name`, а остальные строки передаются как `*data`.

### Значение по умолчанию

В этом уроке я узнал как использовать опциональные аргументы в фукнциях, задавая значения по умолчанию. Опциональные
аргументы позволяют функции работать даже при отсутствии некоторых входных данных.

1. **Создание функции с опциональными аргументами**:
   - Создадим функцию `ext`, которая возводит числов степень. Основные параметры: число (`float`) и степень (`float`).
   - Типизацию в Python можно не использовать, но оа помогает избежать ошибок, указывая на типы входных данных
     (аргументов) и выходных данных (результата).
2. **Значения по умолчанию**:
   - Чтобы избежать ошибок при отсутствии переданого аргумента, можно задать значение по умолчанию (напримр, степень по
     умолчанию равна 2, чтобы число возводилось в квадрат).
   - С использованием значения по умолчанию функция может работать при передаче только одного аргумента.
3. **Правила использования опциональных аргументов**:
   - Опциональные аргументы должны следовать за обязательными.
   - Нельзя задать значение по умолчанию для аргумента, за которым следует обязательный аргумент.
4. **Примеры**:
   - Пример с вызовом `exp(2, 3)` возвращает 8 - без ошибок, так как оба аргумента переданы.
   - Пример с вызовом `exp(2)` использует степень по умолчанию и возвращает 4.
5. **Использование в других функциях**:
   - Как в примере с функцией `print`, которая имеет опциональные аргументы `separator` и `end`, так и в функции `exp`
     можно использовать дефолтные значения для гибкости в вызовах.

Такая настройка опциональных аргументов и дефолтных значений повышает удобство и гибкость использования функций.

### Именованные аргументы

1. **Функция print и ее параметры**:
   - Функция `print` принимает несколько аргументов, среди которых `separator` и `end`.
   - Для изменения только одного из этих параметров используется именованный аргумент.
2. **Порядок и занчение аргументов**:
   - Порядок аргументов имеет значение. Если поменять местами параметры, то изменится и результат.
   - Для избежания прутаницы используйте именованные аргументы. Это позволяет явно указыть, какой параметр к какому
     аргументу относится и избежать неправильной передачи значений.
3. **Пример с функцией возведения в степень**:
   - Создаю функцию, добавляю аргумент `multiplier` с умолчанием 1.
   - Можно задать `vultiplier` через именованные аргументы, чтобы увеличить результат умножения после возведения в
     степень.
4. **Гибкость именованных аргументов**:
   - Именованные аргументы позволяют удобно передавать только нужные значения, не соблюдая строгий порядок.
   - Они полезны, когда нужно изменить параметр, находящийся после параметра с умолчанием.
5. **Использование в пользовательских функциях**:
   - Разберем пример с функцией `print_data`, где `separator` может быть задан 0явно.
   - Такое использование позволяет четко указать, какое значение к какому параметру относится, что исключает ошибки
     впорядке передачи аргументов.
6. **Опциональные аргументы и их гибкость**:
   - Именованные аргументы дают возможность передавать опциональные параметры, находящиеся после других опциональных
     или после параметров, принимающих неограниченное количество значений.
   - Важно, что они позволяют делать код более читаемым и гибким.

### Упражнение - Генерация пароля

Для создания генератора паролей предлагается выполнить следующие шаги:

1. **Определение функции**:  
   Определить функцию `generate_password`, принимающую аргументы:
   - `length`: длина пароля (тип int, по умолчанию 8).
   - `use_symbols`: использовать ли символы (тип bool, по умолчанию True).
2. **Валидация длины**:  
   Проверить если `length` меньше 3, вернуть пустую строку.
3. **Форматирование пула символов**:
   - Импортировать моуль `string` и использовать его `ascii_letters` и `digits` для букв и цифр.
   - Определить вручную символы: `! @ # $ % & * ?`.
   - Объединить буквы, цифры и (если `use_symbols` True) символы в единый pool.
4. **Генерация пароля**:
   - Импортировать модуль `random`.
   - Создать пустой список `password_chars`.
   - Заполнять `password_chars` с помощью `randeom.choice(pool)`, пока его длина не станет равной `length`.
5. **Возврат резултата**:
   - Объединить `password_chars` в строку с помощью `join()` и вернуть.
6. **Тестирование**:
   - Сгенерировать пароли с разными параметрами (например, с длиной 10 и без символов).
   - Вывести результаты в консоль.

## Sets и словари

### Словари

Словари (Dictionaries)

- **Определение и особенности**:
  - Словари хранят данные в виде пар "ключ-значение".
  - В отличие от списков, где доступ осуществляется по индексу, в словарях осуществряется по ключу.
  - Ключи должны быть хэшируемыми (например, строки, числа, булевые значения, кортежи).
- **Хэш-таблицы**:
  - Основой словарей является хэш-таблица, позволяющая быстро находить элементы.
  - Время доступа к элементу ссловаря - О(1), что не зависит от числа элементов в словаре.
  - При одинаковых хэшах различных ключей используется дополнительный сдвиг, решающий коллизии.
- **Создание словарей**:
  - Через фигурные скобки: `{"name": "Андрей", "age": 55}.
  - С использованием функции `dict`: `dict(name="Андрей", age=55)`.
  - Используя список пар "ключ-значение": `dict([("name", "Андрей"), ("age", 37)]).

### Доступ к значениям

В этой лекции я рассматривал работу со словарями в языках программирования, используя Python в качестве примера.

1. **Получение значения по ключу**: Использую квадратные скобки, записывая имя ключа, чтобы получить значение,
   связанное с этим ключом.
2. **Изменение значения**: Аналогично полученоию, просто присваиваем новое значение интересующему ключу.
3. **Добавление нового ключа**: Если ключ отсутствует, при присвоении значения создается новая пара ключ-значение.
4. **Удаление ключа**: Используем метод `pop()`, чтобы удалить ключ и получить значение, которое было связано с ним.
5. **Безопасное получение значения**: Использую метод `get()`, чтобы избежать ошибок доступа к несуществующему ключу.
   Можно задать дефолтное значение, которое будет возвращено, если ключ отсутстсвует.
6. **Проверка наличия ключа**: Использую конструкцию `in` для проверки существования ключа.

Основные функции и методы:

- `user[key]` для получения и изменения.
- `user.get(key, default)` для безопасного получения.
- `user.pop(key)` для удаления.
- `key in user` для проверки наличия ключа.

### Упражнение - Меню приложения

На этом уроке я создал меню для приложения управления паролями. Основные цели:

1. **Создание меню**: Приложение должно при запуске показывать меню с опциями для пользователя:
   - Показать пароли.
   - Добавить пароль.
   - Удалить пароль.
   - Обновить пароль.
   - Выход.
2. **Функция меню**:
   - Создал функцию `show_menu`, которая отображает меню пользователю.
   - Испольовал бесконечный цил `while True` для постоянного показа меню до тех пор, пока пользователь не выберет пункт
     "Выход".
3. **Обработка выбора пользователя**:
   - Ждем ввода пользоватея и преобразуем его выбор в число.
   - Используется структура `match-case` (или аналогичная) для обработки выбора:
     - `case 1`: Показывются пароли.
     - `case 2`: Добавляется пароль.
     - `case 3`: Удаляется пароль.
     - `case 1`: Обновляется пароль.
     - `case 1`: Выход из приложения.
4. **Проверка работы меню**:
   - Запуск приложения, выбор различных пунктов меню для проверки их корректной работы.
   - Подтверждение, что приложение позволяет выбирать пункты и выходить по запросу.

Эта структура является основой для дальнейшего добавления полезных функций в следующих уроках.

### Упражнение - Управление паролями

Резюмирую процесс создания простого приложения для управления паролями с использованием словаря в Python:

1. **Инициализация**: Создается пустой словать `passwords` для хранения паролей. Ключами будут 0домены или названия
   приложений, а значениями - пароли.
2. **Добавление Пароля (add_password)**:
   - Запрашивается у пользователя домен и пароль.
   - Если пароль пустой, генерируется его автоматически.
   - Сохраняются домен и пароль в словарь.
3. **Показ Паролей (show_passwords)**:
   - Просто выводится содержимое словаря, показывая домены и связанные с ними пароли, можно улучшить формат вывода.
4. **Удаление Пароля (delete_password)**:
   - Запрашивается у пользователя домен.
   - Удаляется связанный с доменом пароль из словаря.
   - В случае несуществующего домена, выводится сообщение об отутствии пароля.
5. **Обновление Пароля (update_password)**:
   - Запрашивается у пользователя домен и новый пароль.
   - Проверяется существование домена в словаре.
   - Если домен существует, обновляется пароль, в противном случае сообщается об отсутствии домена.
6. **Улучшения**:
   - Обработка неправильного ввода пользоватея (например, при преобразовании ввода в число).
   - Оптимизируется код с использованием отдельных функций для повторяющихся действий (например, ввод и генерация
     паролей).
7. **Заключение**: Несмотря на то, что парол хранятся только в памяти (и теряются при завершении программы), это
   хорошее вводное упражнение для практики с использованием словарей в Python.

### Итерация по словарю

Итерация по словарям в Python может выполнятсья тремя способами:

1. **По ключам**:
   - Используя цикл `for`, можно перебиравть только ключи словаря. Например:
   ```
   for key in user:
       print(key)
   ```
   - При этом переменная `key` последовательно принимает знаяения кождого ключа (например, `age`, `name`).
2. **По ключу и значению (items)**:
   - Используя метод `items()` у словаря, можно перебирать пары "ключ-значение":
   ```
   for key, value in user.items():
       print(f"{key}: {value}")
   ```
   - Позволяет одновременно использовать и ключ, и соотвествующее ему значение.
3. **Только по значения. (values)**:
   - Используя метод `values()`, можно перебирать только значения словаря:
   ```
   for value in user.values():
       print(value)
   ```

С версии Pyth9on 3.7 сохраняется порядок добавления элементов в словарь. Это значит, что порядок, в котором вы
добавляете элементы, будет соответствовать порядку их итерирования.

Эти методы помогут эффективно работатьб со словарями, например, в таких задачах, как создание генератора паролей.

### Упражнение - Вывод паролей

На этой лекции я рассмотрел, как можно улучшить вывод паролей из словаря, применяя итерирование и форматирование, чтобы
сделать его более читабельным и организованным в виде таблицы.

1. **Задача**: Сделать вывод паролей из словаря более красивым и структурированным.
2. **Методы форматирования**:
   - использование метода `ljust`для добавления пробелов справа от строки, чтобы уравнять их длину и обеспечить
     выравнивание таблички.
   - Альтеранативно, можно применять форматирование строк.
3. **Структура кода**:
   - Сначала распечатка заголовка таблицы с использованием `ljust` для выравнивания.
   - Разделение заголовков и данных вертикальной чертой (двоеточием) и пробелами для визуальной структуры.
   - Итерация по словарю паролей с использованием метода `items()` для получения ключей и значений.
   - Вывод каждого ключа и значения с применением `ljust` для выравнивания.
4. **Типизация**:
   - Указание типа словаря `dict[str, str]` для упрощения работы с методами строк.
5. **Практика**:
   - добавление и отображение нескольких паролей с демонстрацией изменений по длине выводимого контента.
6. **РПезультат**:
   - Получение наглядной таблицы, где каждый ключ пароля и его значение организованно и визуально четко представлен.

### Sets (Множества)

#### Введение в мноества (set) в Python

##### Определение и характеристкики

1. **Множество** (set) - это неупорядоченная коллекция уникльных элементов.
2. Под капотом множество реализуется с использованием **хэш-таблицы**.
3. Множества хранят **только уникальные значения** - дубликаты автоматически удаляются.

##### Отличия от списков (list)

- **Списки** упрорядочены и могут содержать дубликаты.
- **Множества** неупорядочены и не могут содержать дубликаты.
- Списки могут содержать вложенные списки, множества - таолько хэшируемые элементы.

##### Особенности

- Быстрая проверка принадлежности элемента - доступ с временной сложностью O(1).
- Изменяемый тип данных: возможны операции добавления и удаления элементов.

##### Создание множеств

1. **Пустое множество**: `set()`.

```
empty_set = set()
```

2. **Множество с элементами** (через фигурные скобки):

```
sapmple_set = {1, 2, 3, 4, 5}
```

- При добавлении повторяющихся значений они автоматически удаляются:

```
duplicate_set = {1, 2, 2, 3}  # Останутся только 1, 2, 3
```

##### Преобразование других коллекций в set

- Из списка:

```
list_to_set = set([1, 2, 2, 3, 4])
```

- Из кортежа:

```
tuple_to_set = set((1, 2, 3, 3))
```

##### Практическое использование

- Выполняйте операции создания и преобразования с учетом уникальности и неупорядоченности элементов.
- Эффективно используйте множество для операций, требующих проверки принадлежности.

Теперь, зная основы множеств, перехожу к рассмотрению операйий, которые доступны для этих структур данных.

### Операции с множествами

В этой лекции рассмотрены основные операции над множествами (set) в Python, такие как добавление, удаление и проверка
наличия элементов, а также инерирование по множеству.

1. **Создание множества**:
   - Создаем множества `s` с элементами 1, 2, 3, 4.
2. **Добавление элементов**:
   - Используем метод `add` для добавления одного элемента.
   - Метод `update` позволяет добавить несколько элементов из любого итерируемого объекта, например, списка или
     кортежа.
3. **Удаление элементов**:
   - `remove`: удаляет указанный элемент. Если элемента нет, возникает ошибка `KeyError`.
   - `discard`: безопасно удаляет элемент, не вызывая ошибки, если элемент отсутствует.
   - `pop`: удаляет и возвращает первый элемент по настройке этого множества (в реальности - по внутренней
     хэш-таблице).
4. **Проверка наличия элемента**:
   - Оператор `in` используется для проверки, находится ли элемент в множестве.
5. **Итерирование по множеству**:
   - Для итерирования применяем цикл `for`, как и для списков.
6. **Особенности методов**:
   - `pop` возвращает удаленный элемент, тогда как `remove` и `discard` ничего не возвращают.

Эти возможности делают работу с множествами в Python гибкой и эффективной для многих задач.

### Uninon differece и другие

Сегодня я изучил операции над множествами в Python, используя основы теории множеств. Посмотрим на основные операции:

1. **Объединение (Union)**:
   - Создает новое множество, содержащее все уникальные элементы из обоих множеств.
   - Использование: `a.union(b)` или `a | b`.
   - Пример: Объединение `{1, 2, 3}` и `{3, 4, 5}` даст `{1, 2, 3, 4, 5}`.
2. **Пересечение (Intersection)**:
   - Получает элементы, которые есть в обоих множествах.
   - Использование: `a.intersection(b)` или `a & b`.
   - Пример: Пересечение `{1, 2, 3}` и `{3, 4, 5}` даст `{3}`.
3. **Разность (Difference)**:
   - Показывает уникальные элементы первого множества, которых нет во втором.
   - Использование: `a.difference(b)` или `a - b`.
   - Пример: Разность `{1, 2, 3, 4}` и `{3, 4, 5}` даст `{1, 2}`.
4. **Симметричная разность (Symmetric Difference)**:
   - Найти элементы, которые находятся в одном из множеств, но не в обоих.
   - Использование: `a.dymmetric_difference(b)` или `a ^ b`.
   - Пример: Симметричная разнеость `{1, 2, 3}` и `{3, 4, 5}` даст `{1, 2, 4, 5}`.

Эти операции над множествами помогут вам управлять и манипулировать данными в Python, решая различные задачи. Не нужно
глубокое знание теории множеств; достаточно понимать, как использовать эти операции для практических задач. Двигаюсь
дальше.

### Упражнение - Посетители конференции

В этом упражнении я рассмотрел практическое применение сетов (множеств) в реальной задаче, сыязанной с выявлением
уникальных посетителей на мероприятии. Основные шаги включают:

1. **Идентификация уникальных посетителей**:
   - Созадем сеты для каждого дня мероприятия, чтобы получить списки уникальных посетителей. Это позволит избавиться от
     дублирующих записей.
2. **Расчет покзаателей**:
   - Подсчитываю общее количество посетителей и количество уникальных посетителей для каждого дня.
3. **Анализ посещаемости**:
   - Определяем, кто посетил оба дня мероприятия (пересечение мноржеств).
   - Идентифицируем тех, кто посетил только первый день и только второй день (разность множеств).
   - Выясняю, кто был только в один из дней (симметричная разность).
4. **Пример анализа**:
   - Пример содежржит конкретные идентификаторы посетителей и результаты анализа, такие как количество уникльных и
     общих посещений, а также идентификаторы, соответствующие различным категориям (например, тлько первый день, оба
     дня).

Этот процесс демонстрирует, как сеты могут эффективно использоваться для обработки и анализа данных о посещаемости,
обеспечивая простоту в использовании и понимании.

### Сравнение множеств

На этом уроке я узнал, как сравнивать множества и использовать некоторые полезные методы, такие как проверка на
подмножество и надмножество, очистка и копирование множеств.

1. **Подмноежство и надмножество**:
   - Чтобы проверить, является ли одно множество подмножеством другого, используем метод `issubset()`. Например, если
     множество `a` содержит элементы {1, 2}, а множество `b` - {1, 2, 3}, то `a` является подмножеством `b`, т.к. все
     элементы `a` присутствуют в `b`.
   - Для проверки, что одно множество является надмножеством другого, используем метод `issuperset()`. Например, `b`
     является надмножеством `a`.
2. **Сравнение множеств**:
   - Множества мнжно преверять на равенство независимо от проядка элементов. Например, множества {1, 2, 3} и {3, 1, 2}.
     равны, поскольку содержат одинаковые элементы.
3. **Полезные методы**:
   - `clear()`: очищает мноежство, оставляя его пустым.
   - `copy()`: создает копию множества. Копии можно сравнивать с оригиналом, и они будут равны.

Таким образом, я научился сравнивать множества, проверять их на подмножества и надмножества, а также использовать
некоторые вспомогательные методы для работы с множествами.

### Frozenset

Лекция посвящена особенностям использования коллекции данных в Python - frozenset.

1. **Определение frozenset**:
   - forzenset - это неизменяемая версия Set.
   - Неизменяемость позволяет защищать данные от изменений после создания.
2. **Создание frozenset**:
   - Используется функция `frozenset()`.
   - Аргументом выступает любой итерируемый объект, который преобразуется в frozenset.
3. **Особенности frozenset**:
   - Нельзя добавить элемент методом `add`.
   - Нет методов `pop`, `remove` для удаления элементов.
   - Неизменяемость обеспечивает защиту структуры данных.
4. **Операции с frozenset**:
   - Можно сравнривать с другими коллекциями frozenset.
   - Поддерживаются операции объединения, пересечения и другие, как у обычных множеств.
   - результат таких операций также - неизменяемый frozrnbset.
5. **Применение**:
   - Полезен для защиты данных от изменений.
   - Подходит для случаес, когда важна неизменяемость набора данных.
6. **Методы работы с frozenset**:
   - `union` и `subset` для операций с множествами.
   - `copy` для создания копии, однако копия будет неизменяемой.

Итог: frozenset - неизменяемый тип множества в Python, используемый для обеспечения постоянства данных после их
создания.

### Упражение - Провекра документов

В этом упражнении я рассмотрел задачу проверки набора документво для подачи на визу. Я проверяю:

1. **Наличие обязательных документов**:
   - У пользователя должны быть все документы из списка обязательных (паспорт, ИНН, СНИЛС).
   - Проверяется, является ли набор пользовательских документов (user_docs) подмножеством обязательных (required_docs).
2. **Сравнение наборов документов**:
   - Сравниваются два набора документов: обязательные и предоставленные пользователем.
   - Для точного сравнения необходимо испольовать преобразование наборов документвов `forzenset`.
3. **Вывод лишних документов**:
   - Определить какие документы есть у пользователя, но не входят в обязательных список.
   - Выполняется путем вычитания обязательных документов из пользовательских.

В ходе урока я использовал `set` и `frozenset` для операций с множествами. Привел пример, как преобразование в
`frozenset` нужно только при проверке на равенство, но не требуется для операций с подмножествами или вычитанием.

## Функции высшего порядка

### Функции высшего порядка

В этом разделе я изучаю функции высшего порядка.

1. **Определение функций высшего порядка**:
   - Это функции, которые принимают другие функции как аргументы или возвращают функции как результаты.
   - В Python функции являются объектами, поэтому их можно передавать и возвращать, как и любой другой объект.
2. **Переход от строгой типизации к стандартной**:
   - Из-за сложности типизации функций высшего порядка я перейду от строгой типизации Pylint к стандартной, чтобы
     упростить работу на начальном уровне.
3. **Пример функции, принимающей другую функцию**:
   - Функция `apply` принимает функцию и значение, применяет функцию к значению и возвращает результат.
   - Пример: функция `square`, которая возвращает квадрат числа, может быть передана в `apply`.
4. **Рассмотрение примера функции, возвращающей функцию**:
   - Функция `make_adder` создает и возвращает функцию, которая добавляет заданное число.
   - Пример: вызов `make_adder(5)` создаст функцию, которая прибавляет 5 к переданному аргументу.
5. **Итог**:
   - Функции высшего порядка позволяют писать более универсальный и адаптируемый код.
   - Я использовал просую типизацию и примеры для лучшего понимания.

### Lambda

#### Лямбда-функция в Python

1. **Что такое лямбда-функция**?
   - Это анонимная функция, которая позволяет создавать функции без имени.
   - Удобно использовать в функциях высшего порядка, где не нужно объявлять отдельную функцию.
2. **Особенности и ограничения**:
   - Лямбда-выражение должно помещаться в одну строку.
   - После ключевого слова `lambda` следуют аргументы, затем двоеточие и выражение.
   - Ограничение одной строки связано с синтасисом Python.
3. **Пример использования**:
   - Обычная функция:
   ```
   def square(x):
       return x * x
   ```
   - Лямбда-функция:
   ```
   square_lanbda = lambda x: x * x
   ```
   - Лямбда-функция размещается в одной строке, и ее можно сразу использовать.
4. **Практическое применение**:
   - Использование в функции высшего порядка, например, `apply`, которая принимает функцию и значение, и применяет
     функцию к значению.
   - Например:
   ```
   apply(lambda x: x + 100, 5)
   ```
   - Еще один пример для преобразования текста:
   ```
   apply(lambda s: s.upper(), "hi")
   ```
5. **Ограничения лямбда-функций**:
   - Нельзя использовать сложные конструкции, такие как циклы или условные операторы `if`.
   - Лямбда-функции обычно используются для простых операций.

#### Заключение

Лямбда-функции в Python позволяют сократить код, когда не требуется создавать именованные функции, особенно полезны в
фукнциях высшего порядка, но имеют ограничения в сложности выражений.

### Map

На этом уроке рассмотрены функции высшего порядка в Python, которые помогают работать с изменением списков, в
частности функция `map`. Вот основные моменты:

1. **Функция `map`**:
   - Возвращает итератор.
   - Принимает на вход функцию и список элементов.
   - Применяет функцию к каждому элементу списка.
2. **Пример использования `map`**:
   - Задача: возвести каждый элемент списка чисел в квадрат.
   - Без `map`: используется цикл для добавления каждого квадрата в новый список.
   - С `map`: создается итератор через `map`, применяя функцию `square` к каждому элементу списка. Итератор затем
     преобразуется в список.
3. **Оптимизация с помощью `lambda`**:
   - Вместо отдельного объявления функции `square`, используется `lambda` для краткости: `lambda x: x * x`.
4. **Работа с несколькими списками**:
   - `map` может принимать несколько списков для обработки.
   - Пример: сложение двух списков элемент-wise с использованием `lambda x, y: x + y`.
5. **Преимущества `map`**:
   - Уменьшает объем кода.
   - Эффективное использование памяти, так как `map` возвращает итератор, а не список.
   - Позволяет обрабатывать несколько списков одновременно.

### Упражнение - Нормализация данных

1. **Проблема**:
   - Имеются хаотичные данные пользователей: имена с разными регистрами и пробелами, возраст представлен как строка с
     пробелами.
   - Необходимо нормализовать данные для дальнейшего использования.
2. **Цель**:
   - Привести данные пользователей к единому виду:
     - Убрать пробелы и сделать первую букву имен большой.
     - Преобразовать возраст в целое число.
3. **Решение**:
   - Определить список пользователей, где каждый элемен - словать с ключами "name" и "age".
   - Написать функцию `normalize`, котороая будет обрабатывать один элемент списка.
4. \*\*Функция `normalize`:
   - Принимает пользователя (словарь) как входной аргумент.
   - Для ключа "name":
     - Убирает пробелы методом `lstrip()`.
     - Преобразует первую букву в верхний регистр методом `capitalize()`.
   - Для ключа "age":
     - Убирает пробелы методом `lstrip()`.
     - Конвертирует строку в целое число `int`.
5. **Использовение map**:
   - Применяем функцию `normalize` ко всем элементам списка с помощью функции `map()`.
   - Преобразуем результат `map` в список `normalized_users`.
6. **Результат**:
   - Получаем нормализованный список пользователей с корректными именами и возрастом.
