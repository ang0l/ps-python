# Изучаю Python

## Раздел 3. Переменные и типы

### REPL

Сегодня я начинаю изучение Python с простейших математических операций
в так называемом REPL-режиме (Read, Execute, Print, Loop).
Этот режим позволяет вводить командыб которые моментально выполняются и выводят результат.
Повторяется этот процесс до тех пор, пока вы не завершите сессию.
REPL идеально подходит для обучения, тестирования кода и выполнения небольших вычислений без создания новых файлов.

Для начала работы:

1. Убеждаюсь, что Python установлен, проверив его версию в терминале.
2. Открываю терминал в Windows 11 и ввожу команду "py", чтобы войти в REPL.

В этом режиме можно выполнять простые математические операции:

- Например, введя `1 + 2`, получаю результат `3`.
- при делении `10 / 2` получаю `5.0`.

Так же возможен вызов встроенных функцийй, например `print("Привет")` выведет текст "Привет".

Несмотря на ограниченное исиользорвание REPL в больших проектах,
он полезен для изучения базовых операций и встроенных функций Python.

Чтобы выйти из REPL, нужно выполнить команду `exit()`.
Ctrl+C не завершит сессию, поэтому функция `exit()` необходима для выхода.

Поняв основы работы Python в REPL, перейду к созданию первого файла с кодом,
где рассмотрю переменные и другие концепции.

### Создание первого скрипта

Итак, кратко подведу итоги по созданию первого скрипта на Python:

1. **Создание проекта**:
   - Создание новой папки для проекта.
     это можно сделать через файловый менеджер или через терминал командой `mkdir`.
   - Открытие папки в Visual Studio Code.
2. **Создание Python-файла**:
   - Внутри папки создал новый файл с расширением `.py`, например `hello.py`.
     Это обозначает, что файл является Python-скриптом.
3. **Написание кода**:
   - В файле `hello.py` написал код вызова функции `print`, чтобы вывести текст на экран.
4. **Запуск скрипта**:
   - Открыл терминал и выполнил команду `py hello.py` для запуск скрипта.
5. **Проверка результата**:
   - Убедился, что в терминале появилось слово "Привет", что означает успешное выполнение скрипта.

### Переменные в Python

**Что такое переменные и зачем они нужны**

- **Переменная** - это контейнер, который хранит данные, которые можно использовать и изменять в коде.
- Она позволяет сохранить значение, например, число или строку, которое можно использовать многократно.

**Обхявление переменных**

- В Python нет специальных операторов для объявления переменных, как в некоторых других языках.
- Объхявление происходит присвоением значения переменной.

```
py
num = 5
```

**Изменение значений переменных**

- В любую переменную можно поместить новые данные.

```
py
num = 7 # теперь переменная 'num' содержит значение 7
```

**Динамическое изменение типа данных**

- Переменные в Python могут менять свой тип данных динамически.

```
py
num = "привет" # теперь 'num' содержит строку
```

**Правила именования переменных**

- Имя переменной может содержать буквы, цифры и символы подчеркивания, но не может начиинатся с цифры.
- Используем читаемые имена, например, `my_number`.
- Популярные стили: snake*case* (*my*num), PfscalCase(MyNum), CAPS*LOCK* (_MYNUM_) для констант,
  число может быть только в конце (*my*num1).

**Ошибки при неправильном именовании**

-Переменная не может начинаться с цифры, содержать дефисы, пробелы и спецсимволы.

```
py
2num = 5 # ошибка
my-num = 3 # ошибка
my num = 4 # ошибка
```

**Комментарии**

- Комментарии начинаются с символа `#` и игнорируются интерпритатором.

```
py
# Это комментарий
num = 5 # это тоже комментарий
```

Использование переменных как контейнеров для значений, чтобы управлять данными и логикой в коде более эффективно.

### Название переменных

Именование переменных и стиль кода

1. Значение осмысленных названий:
   - Переменные должны иметь понятные, описательные имена.
   - это облегчает понимание и поддержку кода.
2. Пример неверного и верного именования:
   - Вместо a использовать user_age для обозначения возраста пользователя.
3. Стиль именования в Python:
   - Стандарт: lowercacs с нижним подчеркиванием (например, user_age).
   - CamelCase нежелателен, хотя и допустим.
4. Именование функций:
   - Следует аналогичным пправилам, как и для переменных.
   - Название должно отражать функциональность (напримпер, is_admin для логического названия).
5. Типы данных и префиксы:
   - Для логических переменных (boolean) часто используются префиксы is, has.
6. Присвоение множественных значений:
   - Можно присваивать несколько значений одновременно (например, a, b = 1, 4).
   - Использовать только для связанных переменных, например, координаты x и y.
7. Пример хорошей практики:
   - Понятные и описательные названия, чтобы улучшить читаемость и поддержку кода.

### Типы

#### Простейшие типы переменных:

1. **Строки** - текстовые данные.
2. **Числа**:
   - Целые числа (`int`)
   - Числа с плавающей точкой (`float`)
   - Комплексные числа (детально не рассматривались)
3. **Булевые значения** - `True` или `False`

#### Функция `type`:

- Функция `type` используется для определения текущего типа переменной.
- Пример: `type(user.age)` возвращает тип, связанный с `user.age`.

#### Динамическая типизация:

- В Python переменные типизируются динамически; первый присовенный тип значений определяет тип перпеменной.
- Переменная может изменять свой тип при присвоении ей новых значений другого типа.

#### Примеры:

- `user.age = 18` определяет `int`.
- `user.age = "18"` изменяет тип переменной на `str`.

#### Особенности:

- Числа с плавающей точкой (`float`) обозначаются через точку (нопример, `salary = 100.50`).
- Операции между различными числовыми типами выполняются без ошибок,
  итоговые данные приводятся к наиболее подходящему типу (например, результатом сложения int и float будет float).

#### Boolean:

- Булевое значение может быть результатом логического выражения (`10 > 1` дает `True`).
- Слова `True` и `False` пишутся с заглавной буквы вначале.

### Преобразование типов

1. **Автоматическое преобразование типов**:
   - Python может автоматически преобразовывать некоторые совместимые типы, нгапример, int и float.
   - Однако, попытка сложить разные типы, как строку и число, вызовет ошибку.
2. **Явное преобразование типов**:
   - Для преобразования типов используется функция-конструктор типов, например, int(), float(), str(), bool().
   - При преобразовании float в int дробная часть отбрасывается.
   - При неверном преобразовании типов, как строка 'd' в int, возникает ошибка.
3. **Настройка IDE для роверки типов**:
   - в Visual Studio Code через PyLens с режимом "Strict" помогает выявлять ошибки на этапе написания кода.
   - Строгий режим проверки типов позволяет IDE уведомлять о несоответствиях, предотвращая их возникновение на этапе
     выполнения программы.
4. **Преобразование чисел и строк для конкатенации**:
   - Для конкатенации строки и числа необходимо явно преобразовывать число в строку.
   - Это можно сделать с помощью str(), чтобы избежать ошибок на этапе выполнения.
5. **Правила преобразования к boolean**:
   - Для bool() любое значение, кроме нуля и пустой строки, будет интерпретироваться как True.

Рекомендация: всегда включать строгую проверку типов в IDE
и следить за соотвествием типов даннных при написании кода для профессионального подхода к разработке на Python.

### Задание типов

В данной лекции я узнал использование подсказок типов (type hints) в языке программирования Python.

1. **Поведение типов**:
   - Python автоматически определяет тип переменной на основе присваиваемого значения.
   - Например, переменная `x`, которой было присвоено значение целого числа, будет иметь тип `int`.
2. **Изменение типа**:
   - При присваивании нового значения, например, `float` или `str`, тип переменной изменится соответственно.
   - Если попробовать выполнить не совместимые операции между различными типами, возникает ошибка.
3. **Использование type hints**:
   - Чтобы строго определить допустимый тип, использутеся синтаксис `переменная: тип`.
   - Например, `x: int` - указыввает, что `x` должна содержать только `int` значения.
   - Это позволяет избекать ошибок при использовании переменной не по назначению, но не припятствует запуску кода с
     неверным типом в `runtime`.
4. **Янове объявление**:
   - Type hints могут использоваться для предварительного объявления переменных без присваивания конкретного
     значения. Например, `a: int`.
   - Это полезно, когда необходимо заранее сообщить, какие типы ожидаются в будущем.
5. **Практическое применение**:
   - Type hints важны при написании функций и классов, давая возможность явно описывать ожидаемые типы аргументов и
     возвращаемое значение.

### Константы

Константы в Python:

1. **Определение и синтаксис**:
   - В Python нет специального синтаксиса для констант.
   - Константы обозначаются с помощью заглавных бкув (например, `TIME_IN_VILLISECONDS = 1000`).
   - Это условная практика, котороая сигнализирует другим разраотчикам, что значение не должно имзеняться.
2. **Отличия от переменных**:
   - Константы выделяются заглавными буквами, в отличие от переменных с обычными строчным буквами.
   - Переменные могут менять свои значения, тогда как константы предназначены для неизменных значений.
3. **Проверка в IDE**:
   - Средства рзработки (IDE) могут предупреждать о попытке переприсвоения константы.
   - Однако в самом рантайме Python не препятствует изменению значений переменной, обозначенной как константа.
4. **Примеры использования**:
   - Константы часто представяют общепринятые значеения, такие как число PI, скорость света...
   - Они могут включать бизнес-логики, например, количество бонусов за регистрацию.
5. **Наименование**:
   - Константы должны иметь удобочитаемые имена, описывающие их назначение (например, `BONES_POINTS_FOR_REGISTRATION`).
6. **Практика использования**:
   - Соблюдение условностей помогают структуиросвать и поддерживать код.
   - Конвенция использования констант улучшает понимание кода другими разработчиками.

## Раздел 4. Простые операции

### Арифметические операторы

В этой лекции рассмотрены основные операторы в языке Python,
которые используюстя для выполнения математических операций:

1. **Арифметические операторы**:
   - **Сложение** (+): `5 + 7` даст нам 12.
   - **Вычитание** (-): `10 - 3` даст 7.
   - **Умножение** (_): `10 _ 4` даст 40.
   - **Деление** (/): `10 / 2` даст 5.0.
2. **Оператор остатка от деления (modulus, %)**:
   - `5 % 2` даст 1, поскольку делится на 2 с остатком 1.
3. **Деление без остатка**:
   - Исользуется оператор `//`. `7 // 2` даст 3, так как 7 делится на 2 всего три зара, без учета остатка.
4. **Возведение в степень**:
   - Используется оператор `**`. `2 ** 5` даст 32, так как это 2 в пятой степени.
5. **Взятие корня**:
   - Также используется оператор `**`. `9 ** 0.5` даст 3.0, что соответствует квадратному корню из 9.

Эти базовые операторы помогут выполнять основные математические операции в Python.
Для более сложных вычислений, таких как тригонометрические функции,
можно использовать специаьные библиотеки.

### Операторы присвоения

В этом уроке изучены операторы пррисвоения в программировании и их использование.

1. **Осовной оператор присвоения (=)**: Он используется для присваивания значения переменной:
   значение справа присваивается переменной слева.
2. **Короткие записи операторов присвоения**:
   - `+=`: увеличивает переменную на заданное колисество. Например, `a +=5` аналогично `a = a + 5`.
   - `-=`: уменьшает переменную на заданное количество.
   - `*=`: умножает переменную на заданное количество.
   - `/=`: делит переменную на заданное количество, результат певращает в float.
   - `%=`: присваивает остаток от деления.
   - Эти операции позволяют сократить запись арифметических операций и присвоения.
3. **Порядок оператовор**: Оператор присвоения имеет более низкий приоритет, чем арифметические операции,
   поэтому сначала выполняются математическуие выисления, а затем уже присвоение.
4. **Дополнительные операторы присвоения**:
   - **Поибтовые операции**: Существют также сокращенные записи для побитовых операций, например `|=`,
     но их использование требует понимания булевой логики и двоичного представления чисел.
5. **Специфичное использование внутри функции**: Можно создаваать переменные прямо в присваивании внутри функции,
   что упрощает код, если переменная используется только в контексте этой функции.

Это основные моменты, связанные с операторами присвоения, ктотрые делают код более лаконичным и удобочитаемым.

### Операторы сравнения

**Операторы присваивания и сравнения**:

1. Однго равно (`=`) используется для присваивания занчения переменной.
2. Двойное равно(`==`) используется для сравнения значений на равенство.
3. **Практика с переменными**:
   - Создаем переменные `a = 10` и `b = 9`.
   - Сравниваем их `a` == `b` вернет `False`, так как значения не равны.
4. **Булевые значения**:
   - `True` и `False` записываются с большой буквы.
5. **Операторы неравенства**:
   - Проверка на неравенство: `a != b` вернет `True`, если значения не равны.
   - Проверка на больше: `a > b` вернет `True`, если `a` больше `b`.
   - Проверка на меньше: `a < b` вернет `True`, если `a` меньше `b`.
6. **Сложные сравнения**:
   - `a >= b` для проверки больше или равно.
   - `a <= b` для проверки меньше или равно.
7. **Переменные типа `bool`**:
   - Результаты сравнений можно присваивать переменным типа `bool` для дальнейшего использования.
8. **Вывод**:
   - Операторы сравнения возвращают значения типа `bool`: `True` или `False`.
   - Операторы сравнения позволяют гибко и точно работать с условиями в коде.

### Булева логика

**Введение**

Булева логика необходима для понимания операторов в программировании.
Если вы с ней не знакомы, важно ознакомиться с базовыми концепциями,
чтобы эффективно использовать условия в коде.

**Основные Операторы**

1. **И (AND)**
   - Оператор "И" требует, чтобы оба условия были истинными для получения истинного общего результата.
   - Например, выражение "A и B" будет истинным, только если "A" истинное, и "B" истинное.
2. **Или (OR)**
   - Оператор "Или" определяет истинность, если хотя бы одно из условий истинно.
   - Если "A" истинно или "B" истинно (или оба), общее выражение также будет истинным.
3. **Не (NOT)**
   - Оператор "Не" инверсирует значение услоовия: превращает истину в ложь и ложь в истину.
   - Например, "не A" означает, что если "A" истинно, то "не A" будет ложным, и наоборот.

**Примеры использования**

- **Для оператора И**:

  - Если (A > 0) и (A < 10), для (A = 5) выражение истинно, но для (A = 12) - ложно, так как (A < 10) не выполняется.

- **Для оператора Или**:

  - Если (A > 10) или (A < 0), то для (A = 20) или (A = -5) выражение истинно, а для (A = 5) - ложно,
    так как оба условия не выполняются.

- **Для оператора Не**:
  - Если (A > 10), то "не A > 10" равняется (A \leq 10), представляя все, что меньше или равно 10.

### Логические операторы

На этом уроке я научился применять булеву логику в Python с использованием логических операторов: `and`, `or` и `not`.

1. **Операторы в Python**:
   - В Python операторы логики (`and`, `or`, `not`) напрямую соответствуют их английским названиям,
     что упрощает их использование.
   - Они более читаемы по сравнению с другими языками пронраммирования, такими как JavaScript или Golang.
2. **Примеры использования**:
   - **Оператор `and`**:
     - Служит для проверки, чтобы оба условия были истинны.
     - Пример: Пусть `x = 5`. Проверка `x > 0 and x < 10` вернет `True`, так как оба условия выполняются.
   - **Оператор `or`**:
     - Позволяет проверять, чтобы хотя бы одно из условий было истинно.
     - Пример: Для `x = 5`, выражение `x < 0 or x >= 10` вернет `False`, потому что ни одно из условий не выполняется.
   - **Оператор `not`**:
     - Инвертирует логическое значение.
     - Пример: `not(x < 0 or x >= 10)` для `x = 5` вернет `True`, потому что внутри скобок значение `False`.
3. **Вазность порядка операторов**:
   - Важен порядок выполнения операторов. Python сначала выыполняет операторы сравнения (например, `>`, `<`),
     затем борьбу между `and` и `or`, и только после этого выполняется объединение с `not`.
   - Скобки могут использоваться для изменения стандартного порядка выполнения.

### Порядок операторов

В данной лекции я рассмотрел понятие порядка выполнения операторов
и его вазность в вычислениях.
Основные моменты:

1. **Определение**:
   - Порядок выполнения операторов определяет последовательность, в которой вычисляются части выражения
   - Это помогает избежать некорректных вычислений при сложных выражениях.
2. **Приоритет операторов**:
   - Операторы имеют различные уровни приоритета,
     от самого высокого к самому низкому:
     1. эспонентация;
     2. умножение и деление;
     3. сложение и вычитание;
     4. сравнение (больше, меньше, равно);
     5. логические операторы (NOT, AND, OR).
3. **Пример последовательного решения**:
   - Рассматривались примеры, где последовательно применяются операторы в зависимости от их приоритета.
   - Например, вычисление для выражения: (3 \times 4 - 2). Сначала умножение, затем вычитание.
4. **Регулирование порядка**:
   - Для изменения стандартного проядка выполнения операторов используются скобки.
   - Скобки позволяют задать приоритет выполнения операций по желаниям программиста.
5. **Практическая значимость**:
   - Правильное понимание порядка позволяет избежать ошибок в вычислениях.
   - Возможность использования скобок для изменения порядка дает гибкость в написании кода.

### Упражнение - проверка возраста

В этом упражнении мы создали простую прграмму,
которая примимает ввод от пользователя
и оценивает возможность его трудоустройства на долджность бармена на основании возраста.

1. **Получение ввода пользователя**:
   - Использован `input()` для запроса возраста.
   - Пример ввода: `h = input("Введите возраст: ")`.
2. **Преобразование типа**:
   - Поскольку `input()` возвращает строку, преобразовываем его в целое число.
   - Используя `int(h)` для преобразования и сохранения в новой переменной, например, `h_int`.
3. **Логические условия и вывод**:
   - Проверяем возраст: он должен быть больше 18 и меньше 50.
   - Используем логическое выражение: `is_hireable = (h_int > 18) and (h_int < 50)`.
4. **Вывод результата**:
   - Программа должна вывести `True`, если возраст соответствует условиям, и `False`, если нет.
   - Пример вывода: `print(is_hireable)`.
5. **Проверка работы**:
   - Введите разные значения возаста и убедитесь, что программа правильно оценивает каждый из них.
   - Пример работы? ввод 20 даст `True`, а 16 - `False`.

Дополнительно, в коде нет проверки на нечисловой ввод.
Это может вызвать ошибку,
но мы не сосредотачиваемся на этом в данном упражнении.

## Раздел 5. Управление потоком

### if else

1. **Управление потоком**:
   - Начинаю изучение управления потоком в программировании.
   - Использую условия (IF, ELSE) для выполнения различных веток кода в зависимости от условий.
2. **Практический пример**:
   - Условие: разрешение доступа на сайт по возрасту пользователя.
   - Код проверяет, больше ли возраст 18 лет.
3. **Условия IF и ELSE**:
   - Оператор IF используется для проверки условия, например, `age >= 18`.
   - Если условие TRUE, выполняется связанный блок кода.
   - ELSE используется для выполнения кода, если условие FALSE.
4. **Отступы в Python**:
   - В Python нет скобок для обозначения блоков кода.
   - Используются отступы для определения блока кода, принадлежащего условию или циклу.
   - Отступы важны для читаемости и корректности кода.
5. **Пример кода**:
   - Сначала преобразуем ввод возраста в `int`.
   - Используем IF для проверки условия и осуществления необходимых действий.
   - ELSE для обработки случаев, когда условие не выполнено.
6. **Дополнительные условия**:
   - Возможность добавления несколькиз условий, комбенации проверок.
   - Пример: возраст более 18 и менее 50 лет.
7. **Вывод результата**:
   - Пример захватывает возможность изменения потока кода в зависимости от ввода данных.

### Отступы и PEP-8

1. **PEP-8: Что это?**
   - PEP-8: Style Guide для Python, который предлгает стандарты для написания кода.
   - Влючает рекомендации по наимпенованию переменных, структурированию кода, комментированию и другим аспектам.
2. **Фокус на Отступы (Indentation)**
   - Рекомендуемый отступ: 4 пробела.
   - Допустимо использование отступов по табуляции для старого кода, но для нового рекомендуется пробелы.
   - Важно: Каждое слово или фукнция должны иметь консистентные отступы (либо все 4 пробела), либо все табуляции.
3. **Практические настройки в Редакторе**
   - Настройки в редакторе помогают автоматически оформлять код по PEP-8.
   - Параметры для насстройки:
     - `editor.detectIndentation`: false (игнорировать текущие настройки файла).
     - `editor.indertSpaces`: true (вставлять пробелы вместо табуляции).
     - `editor.tabSize`: 4 (число пробелов при нажатии клавиши Tab).
4. **Автоматическое форматирование**
   - Использование функции автосохранения с форматированием (`format onSave`)
     для автоматической корректировки отступов.

Таким образом, PEP-8 настоятельно рекомендует использовать 4 пробела длдя отступов в Python, и его настройки в
редакторе могут помочь поддерживать эти стандарты автоматически.

### elif

Сегдня я рассмотрел, как улучшить читаемасть и удобство кода при проверке нескольких условий
с помщью конструкций IF, ELSEIF и ELSE.

1. **Проблема вложенных условий**:
   - Вложенные конструкции ELSEIF могут быть сложными и нечитабельными.
   - Например, при проверке возраста:
     - Если младше 18, печатаем "вам меньше 18 лет".
     - Если младше 50, но не младше 18, печатаем "вам от 18 до 50 лет".
     - Иначе печатаем "вам больше 50 лет".
2. **Использование ELSEIF (или ELIF)**:
   - Предлагается использовать оператор ELSEIF (в некоторых языках ELLIF), чтобы упростить код.
   - Оператор позволяет куазывать промежуточные условия без вложенности.
3. **Пример кода**:
   ```
   py
   if age < 18:
       print("Вам меньше 18 лет.")
   elif age < 50:
       print("Вам от 18 до 50 лет.")
   else:
       print("Вам больше 50 лет.")
   ```
   - Этот код проще и понятнее, чем использование вложенных IF.
4. **Проверка кода**:
   - Вводим различные значения для возраста: 16, 20, 60.
   - Код корректно обрабатывает и выводит соответствующие сообщения.
5. **Вывод**:
   - Конструкция IF, ELELSE, ELSE удобна для небольшого количества условий.
   - Она обеспечивает простоту и читабельность кода.
   - Для большего количества вариантов можно рассмотреть другие поддходы, которые я узнаю позднее.

Эта структура условий оптимизирует ваш код и повышает его читаемость.

### Тернарный оператор

#### Обзор тернарного оператора

**Тернарный оператор** - это инструмент, который упрощает запись условий и позволяет присваивать значения переменным
на основании логического условия в одну сторку.

**Пример использования**:

1. **Создание переменной**:
   - Изначально создаем переменную `is_legal_age`, которая по умоляанию будет `false`.
2. **Усложное присваивание**:
   - Если `age < 18`, переменная `is_legal_age` остается `false`.
   - Если `age >=18`, переменная `is_legal_age` становится `true`.
3. **Простая запись без else**:
   - Если переменной изначально присвоено `false`, достаточно указывать `true` только при `age >=18`.
4. **Тернарный оператор**:

   - Запись тернарным оператором:

   ```
   is_legal_age = True if age >= 18 else false;
   ```

   - Структура:
     - переменнаяч, которой присваивается значение;
     - логическое условие;
     - значение, когда условие истинно (`true`);
     - значение, когда условие ложно (`false`).

**Преимущества**:

- **Сокращает код**: Позволяет записывать условные конструкции в одну строку.
- **Простота использования**: Удобен для простых операций с присваиванием.

**Пример кода**:

```
int age = 19;
bool is_legal_age = true if age >= 18 else false;
```

Таким образом, тернарный оператор помогает сделать код более компактным и читабельным,
особенно в случаях, кодна требуется простое условное присваивание.

### Упражнение - Максимальное значение

1. **Ввод данных**:
   - Пользователь вводит три числа.
   - Все числа считываются как числа с плавающей точкой.
2. **Инициализация переменных**:
   - Пусть `a`, `b`, `c` будут вводимыми числами, преобразованными в тип `float`.
3. **Проверка условий**:
   - Чтобы найти максимальное число, используем условные операторы.
   - **Если** `a` больше либо равно `b` и `a` больше либо равно `c`, то `a` является максимальным.
   - **Иначе если** `b` больше либо равно `a` и `b` больше либо равно `c`, то `b` является максимальным.
   - **Иначе** максимальным является `c`.
4. **Вывтд результата**:
   - Печатаем наибольшее число из трех введенных.
5. **Пример тестов**:
   - Ввод: 2, 3, 4. Вывод: 4.
   - Ввод: -10, 100, 0. Вывод: 100.
   - Ввод: 1, 1, 1. Вывод: 1.
   - Ввод: 0, 0, 3. Вывод: 3.

### match case

Итак, я рассмотрел, как работать с условиями в Python, используя опператоры if-elif-else
и более современный подход match-case.

1. **Традиционный подхдод (if-elif-else)**:
   - Подходит для проверки роли пользователя, например: если роль "admin" - выводим, что пользователь администратор;
     если "manager" - менеджер, и так далее.
   - Если ни одно из условий не выполнено. Используется else как дефолтный вариант
     (например, определение роли как "уборщица").
2. **Новая конструкция match-case**:
   - Более читаемая и структурированноя альтернатива if-elif-else для случаев, когда нужно сопоставить переменную с
     несколькими значениями.
   - Match используется для переменной, которую надо сравинь. Case определяет варианты (например, 'admin', 'manager').
   - Дефолтный кейс обозначается нижним подчеркиванием (\_), что эквивалентно else.
3. **Особенности match-case**:
   - Возможность объединять несколько значений через вертикальную черту (|), например, 'admin' и 'ADMIN'.
   - Условные проверки внутри кейсов (например, добавить условие a > 0).
   - Для чисел можно использовать match с добавлением условий, хотя это може быть сложнее для восприятия.
4. **Рекомендации**:
   - Match-case лучше подходит для небольших списков значений, когда требуется структура и читаемость.
   - Для более сложных условий, вкючая дополнительные проверки, классический if-elif-else может оказаться более
     подходящим.
   - обязательно включение дефолтного кейса для обработки всех возможных значений.

### Линтер и форматер

В этой лекии обсуждаются инструменты для автоматического соблюдения стандартов форматирования кода в Python при
использовании Visual Studio Code. Рассматриваются две основные утилиты: линтеры иформатеры.

1. **Линтеры**:
   - Линтеры помогают выявлять проблемы в коде и сверять его со стандартами, такими как PEP-8.
   - Они подсвечивают ошибки, например, лишние пробелы, которые нужно убрать.
   - Популярное расширение для Visual Studio Code - Pylint.
   - После установки Pylint автоматически проверяет код на соответствие стандартам.
2. **Форматеры**:
   - Форматеры автоматически исправляют форматирование кода по стандартам.
   - Рекомендуется использовать AutoPEP8 для приведения кода в соответствие с PEP-8.
   - AutoPEP8 форматирует код автоматически при сохранении, убирая лишние пробелы и добавляя необходимые элементы,
     такие как пустые строки.
3. **Практическое применение**:
   - Установка и настройка Pylint и AutoPEP8 обеспечивают автоматическое соблюдение стандартов PEP-8.
   - Эти инструменты важны для написания качественного и чистого кода на Python с самого начала обучения.

Задача данных инструментов - облегчить процесс сблюдения стандартов PEP-8 и помочь обучающимся с первого дня писать
кода правлиьно.

### Упражнение - Лифт

**Цель**:

Разработать простое приложение лифта, которое принимает этаж от пользователя и сообщает о его предназначении.

**Шаги разрабоки**:

1. **Ввод данных**:
   - Используем `input` для получения номера этажа от пользователя.
   - Преобразуем введенные данные в целое число `int`.
2. \*\*Логическая обработка с помощью `matchCase`:
   - **Минус первый этаж (-1)**:
     - Вывести сообщение: "Подвал, здесь находится склад".
   - **Первый этаж (1)**:
     - Вывести сообщение: "Холл и ресепшн".
   - **Этажи с 2 по 9**:
     - Используем дефолтный кейс для проверки, находятся ли этажи в диапазоне 2-9.
     - **Проверка на четность**:
       - Если номер этажа четный, вывести: "Офисный этаж".
       - Если нечентый, вывести: "Жилой этаж".
   - **Десятый этаж (10)**:
     - Вывести сообщение: "Технический этаж, ход запрещен".
   - **Любое другое значение**:
     - Вывести сообщение: "Такого этажа нет".
3. **Особенности**:
   - Простая проверка с использованием `if` для определения четности этажа (делимость на 2).
   - Использование дефолтного кейса для обработки диапазноа этажей от 2 до 9.

**Проверка приложения**:

- Запустить код, введя различные номера этажей (-1, 0, 1-10, 100) и убедиться, что соответствующие сообщения выводятся
  правильно.

## Раздел 6. Списки, кортежи и работа под капотом

### Lists

На этом уроке я разобрался с последовательными типами данных на примере списков в языке программирования Python.

1. **Зачем нужны списки**?
   - Списки используются для хранения последовательности элементов, что удобно для обработки данных, например, записи
     температуры за каждый день.
   - Без списков нам пришлось бы создавать много переменных, что трудно для обаботки.
2. **Что такое списки**?
   - Списки в Python - это динамически изменяемые структуры данных с упорядоченными элементами, доступными по индексу.
     Они поддерживают хранение любых типов данных, включая смешанные типы и вложенные списки (двумерные массивы).
3. **Синтаксис списков**:
   - Списки создаются с помощью квадратных скобок, элементы разделяются запятыми.
   - Пример: `l = [10, 20, "строка", [30, 40]]`.
4. **Индексация**:
   - Индексы начинаются с нуля. Первый элемент списка доступен по индесу 0, последний по индексу `дина списка -1`.
   - Обращение к элементу: `l[index]`.
   - Ошибка при орбращении к несуществующему индексу приводит к `IndexError`.
5. **Отрицательная индексация**:
   - Позволяет обращаться к элементам с конца списка, например, `l[-1]` - последний элемент.
   - Отрицательная индексация начинается с -1, а не с -0.
6. **Изменение списков**:
   - Списки в Python мутабельны: можно менять существующие элементы, добавлять или удалять элементы.
   - Пример: `l[0] = 10` изменяет первый элемент списка.
7. **Создание пустого списка**:
   - Пустой список создается пустыми квадратными скобками: `l = []`.
8. **Типы данных**:
   - Используя `type(l)`, можно узнать тип данных объекта, в данном случяе вернет `<class 'list'>`.

### Tubles

Основные различия между списками и кортежами:

1. **Изменяемость (Mutability)**:
   - **Списки (Lists)**: Изменяемы, можно модифицировать элементы.
   - **Кортежи (Tuples)**: Неизменяемы, нельзя менять элементы напрямую.
2. **Синтаксис**:
   - **Списки**: Используют квадратные скобки `[1, 2, 3]`.
   - **Кортежи**: Используют круглые скобки `(1, 2, 3)`, которые можно даже опустить.

**Работа с длиной**:

- Функция `len()` возвращает длину списка или кортежа.
- Последний элемент можно получить как `[-1]`.

**Изменение внутренних объектов**:

- Несмотря на неизменяемость кортежа, элементы внутри могут быть изменяемыми (нопример, списки внутри кортежа).

**Конвертация**:

- Кортеж можно преобразовать в список с помощью `list()`.
- Список можно преобразовать в кортеж с помощью `tuple()`.

### Строки

#### Работа со строками как с последовательностью

1. **Основное понимание строк**:
   - Строки - это последовательости символов.
   - Тип строки в Python: `str`.
   - Можно работать со строками как со списками и кортажами (доступ к элементам по индексу).
2. **Иммутабельность строк**:
   - Строки, как и кортежи, не изменяемы.
   - Нельзя изменить элемент строки напрямую (например, `name[0] = 'u'` вызовет ошибку).
3. **Основные операции со строками**:
   - Доступ к элементам по индексу, в том числе отрицательным.
   - получение длины строки с помощью `len()`.
4. **Преобразование между типами**:
   - Строку можно преобразовывать в список или кортеж: `list(name)`, `tuple(name)`.
5. **Мультипликация строк**:
   - Умножение строк на число (например, для создания повторяющегося разделителя):
   ```
   separator = "=" * 20
   print(separator)
   ```
6. **Расширяемость операций на другие типы**:
   - Те же операции мультипликации и преобразования применимы и к спискам, и к кортежам.

Тамим образом, строки в Python - это мощный и гибкий инструмент, который можно использовать как и другие
последовательности, позволяя выполнять множество операций для обработки и манипуляции темкстом.

### Об объектах

1. **Понятие Объекта**:
   - Объект в программировании представляет собой репрезентацию чего-то из реального мира или бизнес-процессов.
   - Два ключевых свойства объекта:
     - **Состояние**: текущие характерристики объекта (например, марка и модель автомобиля).
     - **Методы**: действия, которые объект может выполнять (например, ускорение или торможение у автомобиля).
2. **Объекты в Python**:
   - В Python все элементы являются объектами, влючая примитивные типы, такие как числа и строки.
   - Это отличие Python от других языков, где обычно есть разделение между примитивными и сложными типами.
3. **Методы в Python**:
   - Объекты содержат методы, которые можно вызвать для выполнения различных операций.
   - Методы вызываются через точку (например, `строка.capitalize()`).
   - Судествуют методы с двумя подчеркиванимями (например, `__add__`), которые обеспечивают функциональность под
     капотом.
4. **Мутабельные и немутабельные объекты**:
   - Объекты могут быть мутабельными (изменяемыми) и немутабельными (неизменяемыми).
   - Пример мутабельного объекта: список.
   - Пример небумтабельного объекта: строка.
5. **Практическая демонстрация**:
   - Операции, такие как сложение, можно воспринимать как вызов метода над объектами. Например, `10 + 5` может
     проиллюстрировать внутренный вызов `10.__add__(5)`.

### Как работают переменные

В этом уроке я углубился в работу переменных Python.

1. **Создание переменной**:
   - При присвоении переменной значения (например, `a = 10`), в памяти создается объект типа `int` с этим значением.
   - Переменная `a` становится ссылкой на этот объект.
2. **Идентификатор объекта**:
   - Каждый объект в памяти имеет уникльный идентификатор, позволяющий Python отслеживать, где хранится значение.
   - Идентификатор полезен Python для управлления памятью, но разработчику редко требуется его использовать.
3. **Присвоение другой переменной**:
   - Если создать переменную `b`, присвоив ей `a` (`b = a`), обе переменные ссылаются на тот же объект.
   - При изменении `a` (`a = 7`), создается новый объект, и `a` начинает указывать на него, в то время как `b` остается
     с ссылкой на старый объект.
4. **Поведение мутабельных и иммутабельных объектов**:
   - В случае с иммутабельными объектами, такими как `int`, при изменении значения создается новый объект.
   - Продробности о различиях в поведении мутабельных и иммутабельных объектов будут обсцждены в следующих лекциях.
5. **Практическая демонстрация**:
   - Использоватие функции `id()` для вывода идентификаторов переменных позволяет увидеть, как они изменяются при
     присвоении новых значений.

### Mutable и Immutable

Урок посвящен различиям между мутабельными (mutable) и немутабельными (immutable) типами данных в программировании.

1. **Immutable типы**:
   - Пример: целые числа (int), строки (string), кортежи (tuple).
   - При изменении значения создается новая область памяти.
   - Пример: `a = 10`, `b - a`. Если затем `a = 7`, то `a` и `b` указывают на разные области памяти и имеют разные
     значения.
   - Это значит, что `b` останется равным 10, даже если `a` изменится на 7.
2. **Mutable типы**:
   - Пример: списки (list).
   - Объявив список `a = [10, 0]` и присвоив `b = a`, обе переменные ссылаются на один объект.
   - Изменение списка, например `a[0] = 7`, изменяет этот общий объект.
   - После этого `a` и `b` будут иметь одинаковые значения, так как они продолжают ссылаться на один и тот же объект в
     памяти.

### Slicing

На этом уроке я узнал технику "слайсинга" в Python, которая помогает нарезать строки, списки или кортежи на подсписки
или подстроки.

1. **Основы слайсинга**:
   - Слайсинг позволяет выделить часть списка или строки, задав начальный и конечный индекс.
   - Синтаксис: `a[start:stop]`. Здесь `start` - начальный индекс (включительно), `stop` - конечныйы индекс (не включая
     его).
   - Пример: если `a` содержит `[1, 2, 3, 4, 5]`, то `a[0:3]` даст `[1, 2, 3]`.
2. **Пропуск границ**:
   - Можно пропускать начальную и конечную границы: `a[:3]` берет с нулевого до второго индекса, `a[2:]` - со второго
     до конца.
   - Если пропустиь обе границы `a[:]`, это создаст "поверхностную копию" списка.
3. **Shallow copy и его особенности**:
   - Поверхностная копия (`shallow copy`) копирует объект, но не внутренние изменяемые объекты.
   - Например, изменение вложенного списка в `a` отразиться и в копии `b`.
4. **Дополлнительный параметр - шаг**:
   - Третий параметр в слейсинге задает шаг: `a[start:stop:step]`.
   - Пример: `a[0:5:2]` вернет `[1, 3, 5]` (каждый второй элемент).
   - Можно использовать отрицательный шаг для обратного обхода, например, `a[4:0:-1]` вернет `[5, 4, 3, 2]`.
5. **Применение**:
   - Сллайсинг универсален и может использоваться не только со списками, но и со строками и кортежами.
   - Это мощный инструмент для копирования и выборки данных из колллекций.
