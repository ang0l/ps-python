# Изучаю Python

## Раздел 3. Переменные и типы

### REPL

Сегодня я начинаю изучение Python с простейших математических операций в так называемом REPL-режиме (Read, Execute,
Print, Loop). Этот режим позволяет вводить команды которые моментально выполняются и выводят результат. Повторяется
этот процесс до тех пор, пока вы не завершите сессию. REPL идеально подходит для обучения, тестирования кода и
выполнения небольших вычислений без создания новых файлов.

Для начала работы:

1. Убеждаюсь, что Python установлен, проверив его версию в терминале.
2. Открываю терминал в Windows 11 и ввожу команду "py", чтобы войти в REPL.

В этом режиме можно выполнять простые математические операции:

- Например, введя `1 + 2`, получаю результат `3`.
- при делении `10 / 2` получаю `5.0`.

Так же возможен вызов встроенных функцийй, например `print("Привет")` выведет текст "Привет".

Несмотря на ограниченное исиользорвание REPL в больших проектах, он полезен для изучения базовых операций и встроенных
функций Python.

Чтобы выйти из REPL, нужно выполнить команду `exit()`. Ctrl+C не завершит сессию, поэтому функция `exit()` необходима
для выхода.

Поняв основы работы Python в REPL, перейду к созданию первого файла с кодом, где рассмотрю переменные и другие
концепции.

### Создание первого скрипта

Итак, кратко подведу итоги по созданию первого скрипта на Python:

1. **Создание проекта**:
   - Создание новой папки для проекта. Это можно сделать через файловый менеджер или через терминал командой `mkdir`.
   - Открытие папки в Visual Studio Code.
2. **Создание Python-файла**:
   - Внутри папки создал новый файл с расширением `.py`, например `hello.py`. Это обозначает, что файл является
     Python-скриптом.
3. **Написание кода**:
   - В файле `hello.py` написал код вызова функции `print`, чтобы вывести текст на экран.
4. **Запуск скрипта**:
   - Открыл терминал и выполнил команду `py hello.py` для запуск скрипта.
5. **Проверка результата**:
   - Убедился, что в терминале появилось слово "Привет", что означает успешное выполнение скрипта.

### Переменные в Python

**Что такое переменные и зачем они нужны**

- **Переменная** - это контейнер, который хранит данные, которые можно использовать и изменять в коде.
- Она позволяет сохранить значение, например, число или строку, которое можно использовать многократно.

**Обхявление переменных**

- В Python нет специальных операторов для объявления переменных, как в некоторых других языках.
- Объхявление происходит присвоением значения переменной.

```
py
num = 5
```

**Изменение значений переменных**

- В любую переменную можно поместить новые данные.

```
py
num = 7 # теперь переменная 'num' содержит значение 7
```

**Динамическое изменение типа данных**

- Переменные в Python могут менять свой тип данных динамически.

```
py
num = "привет" # теперь 'num' содержит строку
```

**Правила именования переменных**

- Имя переменной может содержать буквы, цифры и символы подчеркивания, но не может начиинатся с цифры.
- Используем читаемые имена, например, `my_number`.
- Популярные стили: snake*case* (*my*num), PfscalCase(MyNum), CAPS*LOCK* (_MYNUM_) для констант,
  число может быть только в конце (*my*num1).

**Ошибки при неправильном именовании**

-Переменная не может начинаться с цифры, содержать дефисы, пробелы и спецсимволы.

```
py
2num = 5 # ошибка
my-num = 3 # ошибка
my num = 4 # ошибка
```

**Комментарии**

- Комментарии начинаются с символа `#` и игнорируются интерпритатором.

```
py
# Это комментарий
num = 5 # это тоже комментарий
```

Использование переменных как контейнеров для значений, чтобы управлять данными и логикой в коде более эффективно.

### Название переменных

Именование переменных и стиль кода

1. Значение осмысленных названий:
   - Переменные должны иметь понятные, описательные имена.
   - это облегчает понимание и поддержку кода.
2. Пример неверного и верного именования:
   - Вместо a использовать user_age для обозначения возраста пользователя.
3. Стиль именования в Python:
   - Стандарт: lowercacs с нижним подчеркиванием (например, user_age).
   - CamelCase нежелателен, хотя и допустим.
4. Именование функций:
   - Следует аналогичным пправилам, как и для переменных.
   - Название должно отражать функциональность (напримпер, is_admin для логического названия).
5. Типы данных и префиксы:
   - Для логических переменных (boolean) часто используются префиксы is, has.
6. Присвоение множественных значений:
   - Можно присваивать несколько значений одновременно (например, a, b = 1, 4).
   - Использовать только для связанных переменных, например, координаты x и y.
7. Пример хорошей практики:
   - Понятные и описательные названия, чтобы улучшить читаемость и поддержку кода.

### Типы

#### Простейшие типы переменных:

1. **Строки** - текстовые данные.
2. **Числа**:
   - Целые числа (`int`)
   - Числа с плавающей точкой (`float`)
   - Комплексные числа (детально не рассматривались)
3. **Булевые значения** - `True` или `False`

#### Функция `type`:

- Функция `type` используется для определения текущего типа переменной.
- Пример: `type(user.age)` возвращает тип, связанный с `user.age`.

#### Динамическая типизация:

- В Python переменные типизируются динамически; первый присовенный тип значений определяет тип перпеменной.
- Переменная может изменять свой тип при присвоении ей новых значений другого типа.

#### Примеры:

- `user.age = 18` определяет `int`.
- `user.age = "18"` изменяет тип переменной на `str`.

#### Особенности:

- Числа с плавающей точкой (`float`) обозначаются через точку (нопример, `salary = 100.50`).
- Операции между различными числовыми типами выполняются без ошибок,
  итоговые данные приводятся к наиболее подходящему типу (например, результатом сложения int и float будет float).

#### Boolean:

- Булевое значение может быть результатом логического выражения (`10 > 1` дает `True`).
- Слова `True` и `False` пишутся с заглавной буквы вначале.

### Преобразование типов

1. **Автоматическое преобразование типов**:
   - Python может автоматически преобразовывать некоторые совместимые типы, нгапример, int и float.
   - Однако, попытка сложить разные типы, как строку и число, вызовет ошибку.
2. **Явное преобразование типов**:
   - Для преобразования типов используется функция-конструктор типов, например, int(), float(), str(), bool().
   - При преобразовании float в int дробная часть отбрасывается.
   - При неверном преобразовании типов, как строка 'd' в int, возникает ошибка.
3. **Настройка IDE для роверки типов**:
   - в Visual Studio Code через PyLens с режимом "Strict" помогает выявлять ошибки на этапе написания кода.
   - Строгий режим проверки типов позволяет IDE уведомлять о несоответствиях, предотвращая их возникновение на этапе
     выполнения программы.
4. **Преобразование чисел и строк для конкатенации**:
   - Для конкатенации строки и числа необходимо явно преобразовывать число в строку.
   - Это можно сделать с помощью str(), чтобы избежать ошибок на этапе выполнения.
5. **Правила преобразования к boolean**:
   - Для bool() любое значение, кроме нуля и пустой строки, будет интерпретироваться как True.

Рекомендация: всегда включать строгую проверку типов в IDE
и следить за соотвествием типов даннных при написании кода для профессионального подхода к разработке на Python.

### Задание типов

В данной лекции я узнал использование подсказок типов (type hints) в языке программирования Python.

1. **Поведение типов**:
   - Python автоматически определяет тип переменной на основе присваиваемого значения.
   - Например, переменная `x`, которой было присвоено значение целого числа, будет иметь тип `int`.
2. **Изменение типа**:
   - При присваивании нового значения, например, `float` или `str`, тип переменной изменится соответственно.
   - Если попробовать выполнить не совместимые операции между различными типами, возникает ошибка.
3. **Использование type hints**:
   - Чтобы строго определить допустимый тип, использутеся синтаксис `переменная: тип`.
   - Например, `x: int` - указыввает, что `x` должна содержать только `int` значения.
   - Это позволяет избекать ошибок при использовании переменной не по назначению, но не припятствует запуску кода с
     неверным типом в `runtime`.
4. **Янове объявление**:
   - Type hints могут использоваться для предварительного объявления переменных без присваивания конкретного
     значения. Например, `a: int`.
   - Это полезно, когда необходимо заранее сообщить, какие типы ожидаются в будущем.
5. **Практическое применение**:
   - Type hints важны при написании функций и классов, давая возможность явно описывать ожидаемые типы аргументов и
     возвращаемое значение.

### Константы

Константы в Python:

1. **Определение и синтаксис**:
   - В Python нет специального синтаксиса для констант.
   - Константы обозначаются с помощью заглавных бкув (например, `TIME_IN_VILLISECONDS = 1000`).
   - Это условная практика, котороая сигнализирует другим разраотчикам, что значение не должно имзеняться.
2. **Отличия от переменных**:
   - Константы выделяются заглавными буквами, в отличие от переменных с обычными строчным буквами.
   - Переменные могут менять свои значения, тогда как константы предназначены для неизменных значений.
3. **Проверка в IDE**:
   - Средства рзработки (IDE) могут предупреждать о попытке переприсвоения константы.
   - Однако в самом рантайме Python не препятствует изменению значений переменной, обозначенной как константа.
4. **Примеры использования**:
   - Константы часто представяют общепринятые значеения, такие как число PI, скорость света...
   - Они могут включать бизнес-логики, например, количество бонусов за регистрацию.
5. **Наименование**:
   - Константы должны иметь удобочитаемые имена, описывающие их назначение (например, `BONES_POINTS_FOR_REGISTRATION`).
6. **Практика использования**:
   - Соблюдение условностей помогают структуиросвать и поддерживать код.
   - Конвенция использования констант улучшает понимание кода другими разработчиками.

## Раздел 4. Простые операции

### Арифметические операторы

В этой лекции рассмотрены основные операторы в языке Python,
которые используюстя для выполнения математических операций:

1. **Арифметические операторы**:
   - **Сложение** (+): `5 + 7` даст нам 12.
   - **Вычитание** (-): `10 - 3` даст 7.
   - **Умножение** (_): `10 _ 4` даст 40.
   - **Деление** (/): `10 / 2` даст 5.0.
2. **Оператор остатка от деления (modulus, %)**:
   - `5 % 2` даст 1, поскольку делится на 2 с остатком 1.
3. **Деление без остатка**:
   - Исользуется оператор `//`. `7 // 2` даст 3, так как 7 делится на 2 всего три зара, без учета остатка.
4. **Возведение в степень**:
   - Используется оператор `**`. `2 ** 5` даст 32, так как это 2 в пятой степени.
5. **Взятие корня**:
   - Также используется оператор `**`. `9 ** 0.5` даст 3.0, что соответствует квадратному корню из 9.

Эти базовые операторы помогут выполнять основные математические операции в Python.
Для более сложных вычислений, таких как тригонометрические функции,
можно использовать специаьные библиотеки.

### Операторы присвоения

В этом уроке изучены операторы пррисвоения в программировании и их использование.

1. **Осовной оператор присвоения (=)**: Он используется для присваивания значения переменной:
   значение справа присваивается переменной слева.
2. **Короткие записи операторов присвоения**:
   - `+=`: увеличивает переменную на заданное колисество. Например, `a +=5` аналогично `a = a + 5`.
   - `-=`: уменьшает переменную на заданное количество.
   - `*=`: умножает переменную на заданное количество.
   - `/=`: делит переменную на заданное количество, результат певращает в float.
   - `%=`: присваивает остаток от деления.
   - Эти операции позволяют сократить запись арифметических операций и присвоения.
3. **Порядок оператовор**: Оператор присвоения имеет более низкий приоритет, чем арифметические операции,
   поэтому сначала выполняются математическуие выисления, а затем уже присвоение.
4. **Дополнительные операторы присвоения**:
   - **Поибтовые операции**: Существют также сокращенные записи для побитовых операций, например `|=`,
     но их использование требует понимания булевой логики и двоичного представления чисел.
5. **Специфичное использование внутри функции**: Можно создаваать переменные прямо в присваивании внутри функции,
   что упрощает код, если переменная используется только в контексте этой функции.

Это основные моменты, связанные с операторами присвоения, ктотрые делают код более лаконичным и удобочитаемым.

### Операторы сравнения

**Операторы присваивания и сравнения**:

1. Однго равно (`=`) используется для присваивания занчения переменной.
2. Двойное равно(`==`) используется для сравнения значений на равенство.
3. **Практика с переменными**:
   - Создаем переменные `a = 10` и `b = 9`.
   - Сравниваем их `a` == `b` вернет `False`, так как значения не равны.
4. **Булевые значения**:
   - `True` и `False` записываются с большой буквы.
5. **Операторы неравенства**:
   - Проверка на неравенство: `a != b` вернет `True`, если значения не равны.
   - Проверка на больше: `a > b` вернет `True`, если `a` больше `b`.
   - Проверка на меньше: `a < b` вернет `True`, если `a` меньше `b`.
6. **Сложные сравнения**:
   - `a >= b` для проверки больше или равно.
   - `a <= b` для проверки меньше или равно.
7. **Переменные типа `bool`**:
   - Результаты сравнений можно присваивать переменным типа `bool` для дальнейшего использования.
8. **Вывод**:
   - Операторы сравнения возвращают значения типа `bool`: `True` или `False`.
   - Операторы сравнения позволяют гибко и точно работать с условиями в коде.

### Булева логика

**Введение**

Булева логика необходима для понимания операторов в программировании.
Если вы с ней не знакомы, важно ознакомиться с базовыми концепциями,
чтобы эффективно использовать условия в коде.

**Основные Операторы**

1. **И (AND)**
   - Оператор "И" требует, чтобы оба условия были истинными для получения истинного общего результата.
   - Например, выражение "A и B" будет истинным, только если "A" истинное, и "B" истинное.
2. **Или (OR)**
   - Оператор "Или" определяет истинность, если хотя бы одно из условий истинно.
   - Если "A" истинно или "B" истинно (или оба), общее выражение также будет истинным.
3. **Не (NOT)**
   - Оператор "Не" инверсирует значение услоовия: превращает истину в ложь и ложь в истину.
   - Например, "не A" означает, что если "A" истинно, то "не A" будет ложным, и наоборот.

**Примеры использования**

- **Для оператора И**:

  - Если (A > 0) и (A < 10), для (A = 5) выражение истинно, но для (A = 12) - ложно, так как (A < 10) не выполняется.

- **Для оператора Или**:

  - Если (A > 10) или (A < 0), то для (A = 20) или (A = -5) выражение истинно, а для (A = 5) - ложно,
    так как оба условия не выполняются.

- **Для оператора Не**:
  - Если (A > 10), то "не A > 10" равняется (A \leq 10), представляя все, что меньше или равно 10.

### Логические операторы

На этом уроке я научился применять булеву логику в Python с использованием логических операторов: `and`, `or` и `not`.

1. **Операторы в Python**:
   - В Python операторы логики (`and`, `or`, `not`) напрямую соответствуют их английским названиям,
     что упрощает их использование.
   - Они более читаемы по сравнению с другими языками пронраммирования, такими как JavaScript или Golang.
2. **Примеры использования**:
   - **Оператор `and`**:
     - Служит для проверки, чтобы оба условия были истинны.
     - Пример: Пусть `x = 5`. Проверка `x > 0 and x < 10` вернет `True`, так как оба условия выполняются.
   - **Оператор `or`**:
     - Позволяет проверять, чтобы хотя бы одно из условий было истинно.
     - Пример: Для `x = 5`, выражение `x < 0 or x >= 10` вернет `False`, потому что ни одно из условий не выполняется.
   - **Оператор `not`**:
     - Инвертирует логическое значение.
     - Пример: `not(x < 0 or x >= 10)` для `x = 5` вернет `True`, потому что внутри скобок значение `False`.
3. **Вазность порядка операторов**:
   - Важен порядок выполнения операторов. Python сначала выыполняет операторы сравнения (например, `>`, `<`),
     затем борьбу между `and` и `or`, и только после этого выполняется объединение с `not`.
   - Скобки могут использоваться для изменения стандартного порядка выполнения.

### Порядок операторов

В данной лекции я рассмотрел понятие порядка выполнения операторов
и его вазность в вычислениях.
Основные моменты:

1. **Определение**:
   - Порядок выполнения операторов определяет последовательность, в которой вычисляются части выражения
   - Это помогает избежать некорректных вычислений при сложных выражениях.
2. **Приоритет операторов**:
   - Операторы имеют различные уровни приоритета,
     от самого высокого к самому низкому:
     1. эспонентация;
     2. умножение и деление;
     3. сложение и вычитание;
     4. сравнение (больше, меньше, равно);
     5. логические операторы (NOT, AND, OR).
3. **Пример последовательного решения**:
   - Рассматривались примеры, где последовательно применяются операторы в зависимости от их приоритета.
   - Например, вычисление для выражения: (3 \times 4 - 2). Сначала умножение, затем вычитание.
4. **Регулирование порядка**:
   - Для изменения стандартного проядка выполнения операторов используются скобки.
   - Скобки позволяют задать приоритет выполнения операций по желаниям программиста.
5. **Практическая значимость**:
   - Правильное понимание порядка позволяет избежать ошибок в вычислениях.
   - Возможность использования скобок для изменения порядка дает гибкость в написании кода.

### Упражнение - проверка возраста

В этом упражнении мы создали простую прграмму,
которая примимает ввод от пользователя
и оценивает возможность его трудоустройства на долджность бармена на основании возраста.

1. **Получение ввода пользователя**:
   - Использован `input()` для запроса возраста.
   - Пример ввода: `h = input("Введите возраст: ")`.
2. **Преобразование типа**:
   - Поскольку `input()` возвращает строку, преобразовываем его в целое число.
   - Используя `int(h)` для преобразования и сохранения в новой переменной, например, `h_int`.
3. **Логические условия и вывод**:
   - Проверяем возраст: он должен быть больше 18 и меньше 50.
   - Используем логическое выражение: `is_hireable = (h_int > 18) and (h_int < 50)`.
4. **Вывод результата**:
   - Программа должна вывести `True`, если возраст соответствует условиям, и `False`, если нет.
   - Пример вывода: `print(is_hireable)`.
5. **Проверка работы**:
   - Введите разные значения возаста и убедитесь, что программа правильно оценивает каждый из них.
   - Пример работы? ввод 20 даст `True`, а 16 - `False`.

Дополнительно, в коде нет проверки на нечисловой ввод.
Это может вызвать ошибку,
но мы не сосредотачиваемся на этом в данном упражнении.

## Раздел 5. Управление потоком

### if else

1. **Управление потоком**:
   - Начинаю изучение управления потоком в программировании.
   - Использую условия (IF, ELSE) для выполнения различных веток кода в зависимости от условий.
2. **Практический пример**:
   - Условие: разрешение доступа на сайт по возрасту пользователя.
   - Код проверяет, больше ли возраст 18 лет.
3. **Условия IF и ELSE**:
   - Оператор IF используется для проверки условия, например, `age >= 18`.
   - Если условие TRUE, выполняется связанный блок кода.
   - ELSE используется для выполнения кода, если условие FALSE.
4. **Отступы в Python**:
   - В Python нет скобок для обозначения блоков кода.
   - Используются отступы для определения блока кода, принадлежащего условию или циклу.
   - Отступы важны для читаемости и корректности кода.
5. **Пример кода**:
   - Сначала преобразуем ввод возраста в `int`.
   - Используем IF для проверки условия и осуществления необходимых действий.
   - ELSE для обработки случаев, когда условие не выполнено.
6. **Дополнительные условия**:
   - Возможность добавления несколькиз условий, комбенации проверок.
   - Пример: возраст более 18 и менее 50 лет.
7. **Вывод результата**:
   - Пример захватывает возможность изменения потока кода в зависимости от ввода данных.

### Отступы и PEP-8

1. **PEP-8: Что это?**
   - PEP-8: Style Guide для Python, который предлгает стандарты для написания кода.
   - Влючает рекомендации по наимпенованию переменных, структурированию кода, комментированию и другим аспектам.
2. **Фокус на Отступы (Indentation)**
   - Рекомендуемый отступ: 4 пробела.
   - Допустимо использование отступов по табуляции для старого кода, но для нового рекомендуется пробелы.
   - Важно: Каждое слово или фукнция должны иметь консистентные отступы (либо все 4 пробела), либо все табуляции.
3. **Практические настройки в Редакторе**
   - Настройки в редакторе помогают автоматически оформлять код по PEP-8.
   - Параметры для насстройки:
     - `editor.detectIndentation`: false (игнорировать текущие настройки файла).
     - `editor.indertSpaces`: true (вставлять пробелы вместо табуляции).
     - `editor.tabSize`: 4 (число пробелов при нажатии клавиши Tab).
4. **Автоматическое форматирование**
   - Использование функции автосохранения с форматированием (`format onSave`)
     для автоматической корректировки отступов.

Таким образом, PEP-8 настоятельно рекомендует использовать 4 пробела длдя отступов в Python, и его настройки в
редакторе могут помочь поддерживать эти стандарты автоматически.

### elif

Сегдня я рассмотрел, как улучшить читаемасть и удобство кода при проверке нескольких условий
с помщью конструкций IF, ELSEIF и ELSE.

1. **Проблема вложенных условий**:
   - Вложенные конструкции ELSEIF могут быть сложными и нечитабельными.
   - Например, при проверке возраста:
     - Если младше 18, печатаем "вам меньше 18 лет".
     - Если младше 50, но не младше 18, печатаем "вам от 18 до 50 лет".
     - Иначе печатаем "вам больше 50 лет".
2. **Использование ELSEIF (или ELIF)**:
   - Предлагается использовать оператор ELSEIF (в некоторых языках ELLIF), чтобы упростить код.
   - Оператор позволяет куазывать промежуточные условия без вложенности.
3. **Пример кода**:
   ```
   py
   if age < 18:
       print("Вам меньше 18 лет.")
   elif age < 50:
       print("Вам от 18 до 50 лет.")
   else:
       print("Вам больше 50 лет.")
   ```
   - Этот код проще и понятнее, чем использование вложенных IF.
4. **Проверка кода**:
   - Вводим различные значения для возраста: 16, 20, 60.
   - Код корректно обрабатывает и выводит соответствующие сообщения.
5. **Вывод**:
   - Конструкция IF, ELELSE, ELSE удобна для небольшого количества условий.
   - Она обеспечивает простоту и читабельность кода.
   - Для большего количества вариантов можно рассмотреть другие поддходы, которые я узнаю позднее.

Эта структура условий оптимизирует ваш код и повышает его читаемость.

### Тернарный оператор

#### Обзор тернарного оператора

**Тернарный оператор** - это инструмент, который упрощает запись условий и позволяет присваивать значения переменным
на основании логического условия в одну сторку.

**Пример использования**:

1. **Создание переменной**:
   - Изначально создаем переменную `is_legal_age`, которая по умоляанию будет `false`.
2. **Усложное присваивание**:
   - Если `age < 18`, переменная `is_legal_age` остается `false`.
   - Если `age >=18`, переменная `is_legal_age` становится `true`.
3. **Простая запись без else**:
   - Если переменной изначально присвоено `false`, достаточно указывать `true` только при `age >=18`.
4. **Тернарный оператор**:

   - Запись тернарным оператором:

   ```
   is_legal_age = True if age >= 18 else false;
   ```

   - Структура:
     - переменнаяч, которой присваивается значение;
     - логическое условие;
     - значение, когда условие истинно (`true`);
     - значение, когда условие ложно (`false`).

**Преимущества**:

- **Сокращает код**: Позволяет записывать условные конструкции в одну строку.
- **Простота использования**: Удобен для простых операций с присваиванием.

**Пример кода**:

```
int age = 19;
bool is_legal_age = true if age >= 18 else false;
```

Таким образом, тернарный оператор помогает сделать код более компактным и читабельным,
особенно в случаях, кодна требуется простое условное присваивание.

### Упражнение - Максимальное значение

1. **Ввод данных**:
   - Пользователь вводит три числа.
   - Все числа считываются как числа с плавающей точкой.
2. **Инициализация переменных**:
   - Пусть `a`, `b`, `c` будут вводимыми числами, преобразованными в тип `float`.
3. **Проверка условий**:
   - Чтобы найти максимальное число, используем условные операторы.
   - **Если** `a` больше либо равно `b` и `a` больше либо равно `c`, то `a` является максимальным.
   - **Иначе если** `b` больше либо равно `a` и `b` больше либо равно `c`, то `b` является максимальным.
   - **Иначе** максимальным является `c`.
4. **Вывтд результата**:
   - Печатаем наибольшее число из трех введенных.
5. **Пример тестов**:
   - Ввод: 2, 3, 4. Вывод: 4.
   - Ввод: -10, 100, 0. Вывод: 100.
   - Ввод: 1, 1, 1. Вывод: 1.
   - Ввод: 0, 0, 3. Вывод: 3.

### match case

Итак, я рассмотрел, как работать с условиями в Python, используя опператоры if-elif-else
и более современный подход match-case.

1. **Традиционный подхдод (if-elif-else)**:
   - Подходит для проверки роли пользователя, например: если роль "admin" - выводим, что пользователь администратор;
     если "manager" - менеджер, и так далее.
   - Если ни одно из условий не выполнено. Используется else как дефолтный вариант
     (например, определение роли как "уборщица").
2. **Новая конструкция match-case**:
   - Более читаемая и структурированноя альтернатива if-elif-else для случаев, когда нужно сопоставить переменную с
     несколькими значениями.
   - Match используется для переменной, которую надо сравинь. Case определяет варианты (например, 'admin', 'manager').
   - Дефолтный кейс обозначается нижним подчеркиванием (\_), что эквивалентно else.
3. **Особенности match-case**:
   - Возможность объединять несколько значений через вертикальную черту (|), например, 'admin' и 'ADMIN'.
   - Условные проверки внутри кейсов (например, добавить условие a > 0).
   - Для чисел можно использовать match с добавлением условий, хотя это може быть сложнее для восприятия.
4. **Рекомендации**:
   - Match-case лучше подходит для небольших списков значений, когда требуется структура и читаемость.
   - Для более сложных условий, вкючая дополнительные проверки, классический if-elif-else может оказаться более
     подходящим.
   - обязательно включение дефолтного кейса для обработки всех возможных значений.

### Линтер и форматер

В этой лекии обсуждаются инструменты для автоматического соблюдения стандартов форматирования кода в Python при
использовании Visual Studio Code. Рассматриваются две основные утилиты: линтеры иформатеры.

1. **Линтеры**:
   - Линтеры помогают выявлять проблемы в коде и сверять его со стандартами, такими как PEP-8.
   - Они подсвечивают ошибки, например, лишние пробелы, которые нужно убрать.
   - Популярное расширение для Visual Studio Code - Pylint.
   - После установки Pylint автоматически проверяет код на соответствие стандартам.
2. **Форматеры**:
   - Форматеры автоматически исправляют форматирование кода по стандартам.
   - Рекомендуется использовать AutoPEP8 для приведения кода в соответствие с PEP-8.
   - AutoPEP8 форматирует код автоматически при сохранении, убирая лишние пробелы и добавляя необходимые элементы,
     такие как пустые строки.
3. **Практическое применение**:
   - Установка и настройка Pylint и AutoPEP8 обеспечивают автоматическое соблюдение стандартов PEP-8.
   - Эти инструменты важны для написания качественного и чистого кода на Python с самого начала обучения.

Задача данных инструментов - облегчить процесс сблюдения стандартов PEP-8 и помочь обучающимся с первого дня писать
кода правлиьно.

### Упражнение - Лифт

**Цель**:

Разработать простое приложение лифта, которое принимает этаж от пользователя и сообщает о его предназначении.

**Шаги разрабоки**:

1. **Ввод данных**:
   - Используем `input` для получения номера этажа от пользователя.
   - Преобразуем введенные данные в целое число `int`.
2. \*\*Логическая обработка с помощью `matchCase`:
   - **Минус первый этаж (-1)**:
     - Вывести сообщение: "Подвал, здесь находится склад".
   - **Первый этаж (1)**:
     - Вывести сообщение: "Холл и ресепшн".
   - **Этажи с 2 по 9**:
     - Используем дефолтный кейс для проверки, находятся ли этажи в диапазоне 2-9.
     - **Проверка на четность**:
       - Если номер этажа четный, вывести: "Офисный этаж".
       - Если нечентый, вывести: "Жилой этаж".
   - **Десятый этаж (10)**:
     - Вывести сообщение: "Технический этаж, ход запрещен".
   - **Любое другое значение**:
     - Вывести сообщение: "Такого этажа нет".
3. **Особенности**:
   - Простая проверка с использованием `if` для определения четности этажа (делимость на 2).
   - Использование дефолтного кейса для обработки диапазноа этажей от 2 до 9.

**Проверка приложения**:

- Запустить код, введя различные номера этажей (-1, 0, 1-10, 100) и убедиться, что соответствующие сообщения выводятся
  правильно.

## Раздел 6. Списки, кортежи и работа под капотом

### Lists

На этом уроке я разобрался с последовательными типами данных на примере списков в языке программирования Python.

1. **Зачем нужны списки**?
   - Списки используются для хранения последовательности элементов, что удобно для обработки данных, например, записи
     температуры за каждый день.
   - Без списков нам пришлось бы создавать много переменных, что трудно для обаботки.
2. **Что такое списки**?
   - Списки в Python - это динамически изменяемые структуры данных с упорядоченными элементами, доступными по индексу.
     Они поддерживают хранение любых типов данных, включая смешанные типы и вложенные списки (двумерные массивы).
3. **Синтаксис списков**:
   - Списки создаются с помощью квадратных скобок, элементы разделяются запятыми.
   - Пример: `l = [10, 20, "строка", [30, 40]]`.
4. **Индексация**:
   - Индексы начинаются с нуля. Первый элемент списка доступен по индесу 0, последний по индексу `дина списка -1`.
   - Обращение к элементу: `l[index]`.
   - Ошибка при орбращении к несуществующему индексу приводит к `IndexError`.
5. **Отрицательная индексация**:
   - Позволяет обращаться к элементам с конца списка, например, `l[-1]` - последний элемент.
   - Отрицательная индексация начинается с -1, а не с -0.
6. **Изменение списков**:
   - Списки в Python мутабельны: можно менять существующие элементы, добавлять или удалять элементы.
   - Пример: `l[0] = 10` изменяет первый элемент списка.
7. **Создание пустого списка**:
   - Пустой список создается пустыми квадратными скобками: `l = []`.
8. **Типы данных**:
   - Используя `type(l)`, можно узнать тип данных объекта, в данном случяе вернет `<class 'list'>`.

### Tubles

Основные различия между списками и кортежами:

1. **Изменяемость (Mutability)**:
   - **Списки (Lists)**: Изменяемы, можно модифицировать элементы.
   - **Кортежи (Tuples)**: Неизменяемы, нельзя менять элементы напрямую.
2. **Синтаксис**:
   - **Списки**: Используют квадратные скобки `[1, 2, 3]`.
   - **Кортежи**: Используют круглые скобки `(1, 2, 3)`, которые можно даже опустить.

**Работа с длиной**:

- Функция `len()` возвращает длину списка или кортежа.
- Последний элемент можно получить как `[-1]`.

**Изменение внутренних объектов**:

- Несмотря на неизменяемость кортежа, элементы внутри могут быть изменяемыми (нопример, списки внутри кортежа).

**Конвертация**:

- Кортеж можно преобразовать в список с помощью `list()`.
- Список можно преобразовать в кортеж с помощью `tuple()`.

### Строки

#### Работа со строками как с последовательностью

1. **Основное понимание строк**:
   - Строки - это последовательости символов.
   - Тип строки в Python: `str`.
   - Можно работать со строками как со списками и кортажами (доступ к элементам по индексу).
2. **Иммутабельность строк**:
   - Строки, как и кортежи, не изменяемы.
   - Нельзя изменить элемент строки напрямую (например, `name[0] = 'u'` вызовет ошибку).
3. **Основные операции со строками**:
   - Доступ к элементам по индексу, в том числе отрицательным.
   - получение длины строки с помощью `len()`.
4. **Преобразование между типами**:
   - Строку можно преобразовывать в список или кортеж: `list(name)`, `tuple(name)`.
5. **Мультипликация строк**:
   - Умножение строк на число (например, для создания повторяющегося разделителя):
   ```
   separator = "=" * 20
   print(separator)
   ```
6. **Расширяемость операций на другие типы**:
   - Те же операции мультипликации и преобразования применимы и к спискам, и к кортежам.

Тамим образом, строки в Python - это мощный и гибкий инструмент, который можно использовать как и другие
последовательности, позволяя выполнять множество операций для обработки и манипуляции темкстом.

### Об объектах

1. **Понятие Объекта**:
   - Объект в программировании представляет собой репрезентацию чего-то из реального мира или бизнес-процессов.
   - Два ключевых свойства объекта:
     - **Состояние**: текущие характерристики объекта (например, марка и модель автомобиля).
     - **Методы**: действия, которые объект может выполнять (например, ускорение или торможение у автомобиля).
2. **Объекты в Python**:
   - В Python все элементы являются объектами, влючая примитивные типы, такие как числа и строки.
   - Это отличие Python от других языков, где обычно есть разделение между примитивными и сложными типами.
3. **Методы в Python**:
   - Объекты содержат методы, которые можно вызвать для выполнения различных операций.
   - Методы вызываются через точку (например, `строка.capitalize()`).
   - Судествуют методы с двумя подчеркиванимями (например, `__add__`), которые обеспечивают функциональность под
     капотом.
4. **Мутабельные и немутабельные объекты**:
   - Объекты могут быть мутабельными (изменяемыми) и немутабельными (неизменяемыми).
   - Пример мутабельного объекта: список.
   - Пример небумтабельного объекта: строка.
5. **Практическая демонстрация**:
   - Операции, такие как сложение, можно воспринимать как вызов метода над объектами. Например, `10 + 5` может
     проиллюстрировать внутренный вызов `10.__add__(5)`.

### Как работают переменные

В этом уроке я углубился в работу переменных Python.

1. **Создание переменной**:
   - При присвоении переменной значения (например, `a = 10`), в памяти создается объект типа `int` с этим значением.
   - Переменная `a` становится ссылкой на этот объект.
2. **Идентификатор объекта**:
   - Каждый объект в памяти имеет уникльный идентификатор, позволяющий Python отслеживать, где хранится значение.
   - Идентификатор полезен Python для управления памятью, но разработчику редко требуется его использовать.
3. **Присвоение другой переменной**:
   - Если создать переменную `b`, присвоив ей `a` (`b = a`), обе переменные ссылаются на тот же объект.
   - При изменении `a` (`a = 7`), создается новый объект, и `a` начинает указывать на него, в то время как `b` остается
     с ссылкой на старый объект.
4. **Поведение мутабельных и иммутабельных объектов**:
   - В случае с иммутабельными объектами, такими как `int`, при изменении значения создается новый объект.
   - Продробности о различиях в поведении мутабельных и иммутабельных объектов будут обсцждены в следующих лекциях.
5. **Практическая демонстрация**:
   - Использоватие функции `id()` для вывода идентификаторов переменных позволяет увидеть, как они изменяются при
     присвоении новых значений.

### Mutable и Immutable

Урок посвящен различиям между мутабельными (mutable) и немутабельными (immutable) типами данных в программировании.

1. **Immutable типы**:
   - Пример: целые числа (int), строки (string), кортежи (tuple).
   - При изменении значения создается новая область памяти.
   - Пример: `a = 10`, `b - a`. Если затем `a = 7`, то `a` и `b` указывают на разные области памяти и имеют разные
     значения.
   - Это значит, что `b` останется равным 10, даже если `a` изменится на 7.
2. **Mutable типы**:
   - Пример: списки (list).
   - Объявив список `a = [10, 0]` и присвоив `b = a`, обе переменные ссылаются на один объект.
   - Изменение списка, например `a[0] = 7`, изменяет этот общий объект.
   - После этого `a` и `b` будут иметь одинаковые значения, так как они продолжают ссылаться на один и тот же объект в
     памяти.

### Slicing

На этом уроке я узнал технику "слайсинга" в Python, которая помогает нарезать строки, списки или кортежи на подсписки
или подстроки.

1. **Основы слайсинга**:
   - Слайсинг позволяет выделить часть списка или строки, задав начальный и конечный индекс.
   - Синтаксис: `a[start:stop]`. Здесь `start` - начальный индекс (включительно), `stop` - конечныйы индекс (не включая
     его).
   - Пример: если `a` содержит `[1, 2, 3, 4, 5]`, то `a[0:3]` даст `[1, 2, 3]`.
2. **Пропуск границ**:
   - Можно пропускать начальную и конечную границы: `a[:3]` берет с нулевого до второго индекса, `a[2:]` - со второго
     до конца.
   - Если пропустиь обе границы `a[:]`, это создаст "поверхностную копию" списка.
3. **Shallow copy и его особенности**:
   - Поверхностная копия (`shallow copy`) копирует объект, но не внутренние изменяемые объекты.
   - Например, изменение вложенного списка в `a` отразиться и в копии `b`.
4. **Дополнительный параметр - шаг**:
   - Третий параметр в слейсинге задает шаг: `a[start:stop:step]`.
   - Пример: `a[0:5:2]` вернет `[1, 3, 5]` (каждый второй элемент).
   - Можно использовать отрицательный шаг для обратного обхода, например, `a[4:0:-1]` вернет `[5, 4, 3, 2]`.
5. **Применение**:
   - Слайсинг универсален и может использоваться не только со списками, но и со строками и кортежами.
   - Это мощный инструмент для копирования и выборки данных из колллекций.

### Упражнение - Палиндром

Сегодня я учился, как написать программу на Python для проверки, является ли введенное пользователем слово палиндромом.

1. **Определение палиндрома**: Слово, которое читается одинаково как слева направо, так и справа налево. Примеры:
   "Топот", "Шалаш", "Мадам". Пример, который не является палиндромом: "Привет".
2. **Цель упражнения**: Создать программу, которая получет ввод пользователя и проверяет, является ли введенное слово
   палиндромомм, используя конструкции `if`, `else` и слайсы.
3. **Шаги выполнения программы**:
   - Запросите у пользователя ввод с помощью функции `input()`.
   - Преобразуйте введенное словво в нижний регистр для корректной проверки, используя метод `lower()`.
   - Инвертируйте слово, используя слайсы `inverted_word = word[::-1]`.
   - Проверьте равенство исходного и инвертированного слова:
     - Если они равны, слово является палиндромом - выводим "Да".
     - Если не равны - выводим "Нет".

### Манипуляция со списками

Сегодня я рассмотрел манипуляции со списками: добавление, удаление и замену элементов.

1. **Замена элементов**:
   - Чтобы заменить элемент, нужно обратиться к нему по индексу.
   - Например, замена первого элемента (индекс 0) в списке `[1, 2, 3, 4, 5]` на 7: результат будет `[7, 2, 3, 4, 5]`.
   - Можно заменить сразу несколько элементов, передав новый список или кортеж. Например, замена элементов с 0-го по
     2-й индекс: передав `(7, 8)`, мы получим `[7, 8, 3, 4, 5]`.
2. **Удаление элементов**:
   - Используется ключевое слово `del`.
   - Например, удаление элемента на индексе 0 из `[1, 2, 3, 4, 5]` даст результат `[2, 3, 4, 5]`.
   - Аналогично можно удалить несколько элементов, указав диапазон индексов.
3. **Добавление элементов**:
   - **Метод** `append`: добавляет элемент в конец списка.
     - Пример: `l.append(6)` для списка `[1, 2, 3, 4, 5]` даст `[1, 2, 3, 4, 5, 6]`.
   - **Метод** `extend`: расширяет список элементами из другого списка или кортежа.
     - Пример: `l.extend([6, 7])` добавит `[6, 7]` к списку.
   - **Метод** `insert`: вставляет элемент в указанную позицию.
     - Пример: `l.insert(0, 1)` добавит `1` в начало списка (индекс 0), получим `[0, 1, 2, 3, 4, 5]`.
4. **Производительность**:
   - `append` работает быстрее, так как добавляет элемент в конец списка.
   - `insert` может быть медленнее, так как требует перемещения элементов, особенно на больших массивах.

### Копирование

1. **Основы копирования**:
   - Создание новой переменной для списка (например, `l = c`) приводит к тому, что обе переменные `c` и `l` указывают
     на одну и ту же область памяти.
   - Оператор `is` может использоваться для проверки, указывают ли две переменные на одну и ту же область памяти. Если
     `c is l`, это означает, что они идентичны по месту в памяти.
2. **Проверка равенства**:
   - Оператор `==` используется для проверки, содержат ли списки одинаковые значения, даже если они находятся в разных
     областях памяти.
3. **Shallow Copy (поверхностная копия)**:
   - Создание поверхностной копии с использованием срезов (например, `c = l[:]`) или метода `copy()` создает новый
     объект списка, но элементы внутри него все еще ссылаются на исходные обхекты в памяти.
   - При изменении элементов, которые являются вложенными объектами (например, списками внутри списка), изменения
     отразятся на обоих списках.
4. **Deep Copy (глубокая копия)**:
   - Для создания полной копии объекта, включая вложенные объекты, используется `deepcopy` из модуля `copy`. Это
     позволяет избежать ссылок на изначальные объекты внутри нового списка.

### Unpack

#### Распаквка (Unpack) в Python

Распаковка или `unpack` - это процесс извлечения элементов из списков, кортежей или строк в одельные переменные.

**Основные концепции**:

1. **Пример с кортежем**:
   - Пусть есть переменная `user`, хранящая кортеж (`name`, `age`).
   - Чтобы извлечь элементы:
   ```
   name, age = user
   ```
   - Количество переменных должно совпадать с количеством элементов в кортеже.
2. **Ошибки распаковки**:
   - Если переменных меньше: ошибка "not enough values to unpack".
   - если переменных больше: ошибка "too many values to unpack".
3. **Работа с другими структурами**:
   - **Список**: Можно распаковать так же, как и кортеж.
   - **Строка**: Можно распаковать как последовательность символов.

**Применение**:

- **Обмен значений переменных**:
  - Используя распаковку, легко поменять значения переменных `a` и `b`.
  ```
  a, b = b, a
  ```
  - Это работает благодаря оценке правой части и последующему присвоению левой.

**Важные аспекты**:

- Распаковка формирует кортеж и оценивает правую часть до присвоения переменным слева.
- Это эффективно упрощает код без использования временных переменных.

### iterable unpack

В этой лекции обсуждался "star syntax" в Python, который позволяет распаковывать элементы списка, даже если их
количство больше, чем число переменных, в которые мы собираемся из разложить.

1. **Основы Unpack**:
   - Стандартный метод распаковки предполагает, что количество переменных совпадает с количеством элементов в списке.
2. **Star Syntax**:
   - Позволяет положить "остаток" списка в одну переменную.
   - Пример: есть список `[1, 2,  3, 4, 5]`; можно распаковать первый элемент в переменную `first`, а остальнрые в -
     `rest` (`first, *rest = [1, 2, 3, 4, 5]`).
   - `rest` будет списком `[2, 3, 4, 5]`.
3. **Ограничения**:
   - Нельзя использовать `*` более одного раза в одном unpack выражении.
4. **Гибкость использования**:
   - Можнжо распаковывать элементы в несколько переменных, например, `first, second, *rest, pre_last, last`.
5. **Тип полученной переменной**:
   - `rest` всегда будет списком.

### Упражнение - Сумма границ

В данном упражнении я рассмотрел задачу по суммированию элементов списка, изучая при этом функцию SUM. Вот основные
моменты:

1. **Задача**:
   - Дан список чисел.
   - Необходимо суммировать крайние элементы (первый и последний).
   - Суммировать все остальные элементы в отдельный результат.
   - Вывести результаты в виде кортежа (сумма крайних элементов, сумма всех остальных).
2. **Использование функции SUM**:
   - SUM используется для суммирования элементов итерируемых объектов.
   - Например, SUM([1, 2, 3]) вернет 6.
3. **Реализация**:
   - Использовал распаковку списка для получения первых и последних элементов и всех остальных.
   - Пример кода:
   ```
   first, *middle, last = [10, 1, 2, 3, 5]
   fesult = (first + last, sum(middle))
   ```
   - SUM возвращает 0 при суммировании пустого списка.
4. **Особые случаи**:
   - Если в списке меньше двух элементов, обработка невозможна без модификаций, так как некому быть "last".
5. **Проверка**:
   - Протестировал разные входные данные, включая случаи с маленькими и большими списками.
   - Важно учесть, что корректная обработка списка с двумя элементами также должна быть предусмотрена.

Эти инструкции помогли решить задачу, обработать разные случаи и использовать SUM эффективно.

## Раздел 7. Строки

### Строки и Unicode

В этом разделе будет углубление в изучение строк в Python:

1. **Гомогенность строк**:
   - Строки состоят только из символов (букв, цифр, специальных символов).
   - В отличие от списков или кортежей, элементы в троках однотипны.
2. **Unicode в Python**:
   - Все строки в Python по умолчанию состоят из Unicode-символов.
   - Unicode кодировка поддерживает не только латинские буквы, но и эмоджи, буквы различных алфавитов, специальные
     символы.
3. **Работа с Unicode**:
   - Использование функции `ord()` для получения Unicode-номера символа: например, 'a' имеет номер 97.
   - Функция `chr()` позволяет преобразовать Unicode-номер обратно в символ. Нопрример, `chr(128640)` вернет эмоджи
     ракеты 🚀.
4. **Ограничения использования Unicode**:
   - Эмоджи и специальные символы могут быть частью строки, но не могут использоваться в качестве имени переменной.

### Изменение строк

На этом уроке был рассмотрен важный аспект работы со строками в Python и методы, позволяющие их модифицировать:

1. **Отличия строк от списков**: Строки состоят исключительно из символов Uicode и обладают множеством спеифичных
   методов, недоступных для списков или кортежей.
2. **Методы модификации строк**:
   - `upper()`: переводит все символы строки в верхний регистр.
   - `capitalize()`: делает первую букву строки заглавной.
   - `lower()`: переводит все символы строки в нижний регистр.
   - `strip()`: удаляет пробелы по краям строки.
   - `replace()`: заменяет указанные символы или подстроки на новые (можно заменить все вхождения).
   - `split()`: разбивает строку по указанному символуЮ, возврацая список.
3. **Multiline String**:
   - Может быть записана с использованием тройных кавычек (одинарных или двойных) и позволяет создавать строки,
     разделенные на несколько строк кода.
   - Позволяет применять все те же методы, что и однострочные строки.
   - `splitlines()`: разделяет строку на линии и возвращает список строк.

### Методы строк

На этом уроке я изучил основные методы работы со строками в программировании, которые могут быть полезны:

1. **count** - возвращает количество вхождений определенного символа в строке. Учитывает регистр.
2. **startswith и endswith** - проверяют, начинается или заканчивается строка определенной подстрокой. Возвращают
   `true` или `false`.
3. **find и rfind** - ищут индекс первого вхождения символа в строке слева направо и справа налево соответственно.
   Возвращают индекс или `-1`, если символ не найден.
4. **index и rindex** - аналогичны find и rfind, но выбрасывают ошибку, если символ не найден.
5. **isdigit, isdecimal, islower, isnumeric** и др. - позволяют проверить разные свойства строк, например, стостоит ли
   строка только из цифр, является ли она прописной и т.д. `isnumeric` помогает проверить, можно ли строку
   преобразовать в число.
6. **join** - объединяет элементы списка или кортежа в строку с заданным разделителем.

### Упражнение - Проверка email

Это упражнение посвящено проверке корректности e-mail. Основная задача - реализовать базовую проверку e-mail без
использования сложных библиотек.

1. **Цель**: Проверить корректность e-mail путем проверки структуры. Необходимо наличие локальной части, домена второго
   уровня, символа '@', точи и домена первого уровня (две буквы).
2. **Процесс проверки**:
   - Порлучить введенный e-mail от пользователя.
   - Проверить, что '@' встречается ровно один раз.
   - Разделить e-mail по '@' на две части: локальный пользователь и домен.
   - Проверить, что локальная часть не пустая.
   - Убедиться, что в домене присутствует точка.
   - Проверить, что длина домена первого уровня (после последней точки) составляет минимум две буквы.
   - Проверить, что домен второго уровня (часть до последней точки) не пустой.
3. **Дополнительные знания**:
   - Использование метода `find` и оператора `in` для поиска символов в строке.
   - Использование команды `exit()` для завершения программы.

### Интерполяция строк

Сегодня я рассмотрел три метода форматирования строк в Python: конкантенацию, метод `format` и f-строки.

1. **Конкатенация**:
   - Используем `+` для соединения строк и переменных.
   - Необходимо вручную следить за пробелами и конвертировать числа в строки.
   - Подвержено ошибкам и выглядит громоздко.
2. **Метод `format`**:
   - Используем фигурные скобки `{}` как плейсхолдеры в строке.
   - Затем применяем метод `format()`, передавая туда переменые в нужном порядке.
   - Порядок важен; для настройки можно использовать именованные аргкменты.
   - Несмотря на улучшение, метод устарел.
3. **F-строки (f-strings)**:
   - Появились с Python 3.6, отмечаются буквой `f` перед кавычками.
   - Вместо плейсхолдеров используем переменные прямо в строке, обернув их в `{}`.
   - Поддерживают встроенные выражения и форматирование вывода.
   - Наиболее читаемый и современный способ.

Вывод: f-строки - это лучший современный способ форматирования строк в Python. Они обеспечивают простоту и гибкость,
сокращая объем кода и повышая его читаемость.

### Escape Characters

1. **Понятие Escape Characters**:
   - Escape character - это специальный символ (бэкслэш), который используется для экранирования символов в строках.
2. **Экранирование кавычек**:
   - Если строка содержит кавычки, совпадающие с символами начала и конца, их можно экранировать бэкслэшем:
     - Пример: `"Привет, \"ООО Рога и копыта\""`
     - Используется для правильного отобнражения строк с кавычками внутри.
3. **Вывод бэкслэша**:
   - Чтобы вывести бэкслэш, нужно экранировать его двойным бэкслэшем: `\`.
4. **Специальные символы через escape character**:
   - **Перенос строки**: `\n`
     - Пример: `"Привет\nКак дела?"` - текст разделяется на две строки.
   - **Возврат каретки**: `\r`
     - Заменяет текст до символа каретки на новое значение.
     - Пример: `Привет\rКак дела?` выведет "Как дела?"
   - **Табуляция**: `\t`
     - Добавляет отступ или табуляцию.
     - Пример: `"Привет\tКак дела?"`.
   - **Бэкспейс**: `\b`
     - Удаляет последний символ перед ним в строке.
     - Пример: `"Привет\b!"` удалит восклицательный знак.

### Упражнение - Письмо

На этом уроке разирается создание шаблона письма с использованием f-ммтрок и переносов строк.

Основные моменты:

1. **Цель**: создать шаблон письма с приветствием, информацией о счете и просьбой об оплате.
2. **Испрользование f-строк**: Позволяет вставлять переменные внутрь строк.
   - Пример: `f"Здравствуйте, {name}!"`.
3. **Перенос строк**:
   - Вместо запятой моно использоать скобки, чтобы разделить строки для визуального удобства.
4. **Форматирование чисел**:
   - Пример форматирования числа с двумя знаками после запятой: `f"{total:.2f}"`.
5. **Умножение строк**:
   - Можно повторить строку несколько раз: `"-" * 30`.

## Раздел 8. Циклы

### Функция range

1. **Введение в циклы**
   - Циклы позволяют перебирать элементы внутри последовательностейб таких как списки или кортежи.
   - Я буду использоватеь циклы для обработки каждого элемента отдельно.
2. **Функция range**
   - **Назначение**: Создает последовательности чисел.
   - **Отилчие от списков**: Не хранит всю последовательность целиком, выдает следующий элемент по запросу.
   - **Пример**: `range(10)` генерирует число от 0 до 9 (правая граница исключается).
3. **Работа с range**
   - Преобразуем range в список для визуализации: `list(range(10))` даст `[0, 1, 2, ..., 9]`.
   - **Эффективность**: Range эффективнее по памяти для больших последовательностей, так как не хранит полный список.
   - **Тип**: `type(range)` - это объект класса Range, который хранит текущий и следующий элемент.
4. **Настройки Range**
   - **Начальное значение**: `range(5, 10)` даст числа от 5 до 9.
   - **Задание шага**:
     - `range(5, 10, 2)` будет 5, 7, 9.
     - Можно использовать отрицательный шаг, например, `range(10, 0, -1)`.
5. **Применимость range**
   - Полезен для создания числовых последовательностей, особенно в циклах.
   - Помогает в оптимизации кода при работе с большими последовательностями.

### Цикл for

#### Лекция: Циклы в Python - Цикл FOR

**Введение в циклы**

- Циклы позволяют повторять заданный код определенное количество раз.
- Они могут использоваться с различными наборами данных: списками (LIST), последовательносями (RANGE),
  кортежами (TUPLE).

**Струтура цкла FOR**

1. **Ключевые слова**: `FOR` и `IN`.
   `FOR` начинается цикл.
   `IN` указывает на коллекцию данных для итерирования.
2. **Переменная цикла**:
   - Ноходится между `FOR` и `IN`.
   - Каждый раз принимает значение из текущего элемента итерируемой коллекции.
3. **Пример цикла**:
   - Имеем числа: 1, 2, 3, 4, 5.
   - На каждой итерации переменная будет принимать последовательно значения: 1, 2, 3, 4, 5.
4. **Тело цикла**:
   - Заключенные в отступе команды, которые выполняются на каждой итерации.

**Пример работы с циклами**

- **Пример с именами**:
  - Используем список имен: Андрей, Вася, Катя.
  - Для каждого имени вывести приветствие.
  - Код:
  ```
  names = ["Андрей", "Вася", "Катя"]
  for name in names:
      print(f"Привет, {name})`
  ```
- **Пример с RANGE**:
  - Создаем диапазон от 0 до 4.
  - Выводим каждое число на экран.
  - Код:
  ```
  for num in range(5):
      print(num)
  ```

**Пример использования цикла на практике**

- **Вычисление суммы**:
  - Имеем список расходов: 10, 20, 30, 100.
  - Суммируем элемеенты списка.
  - Код:
  ```
  expenses = [10, 20, 30, 100]
  total = 0
  for expense in expenses:
      total += expense
  print(total) # Вывод: 160
  ```

**Заключение**

- Циклы являются важным инструментом для выполнения повторяющихся действий.
- В дальнейшем рассмотрю более сложные примеры и с пособы управления циклами.

### Enumerate

1. **Циклы и элементы**:
   - Ранее мы использовали циклы для работы с элементами списка, выполняя с ними операции, такие как суммирование или
     вывод в консоль.
2. **Индексы**:
   - Для некоторых задач необходимо знать не только значение элемента, но и его индекс в списке.
   - Пример: надо пометить оценки ниже 60 как "не сдал".
3. **Функция `enumerate`**:
   - Преобразует итерации: позволяет получить как значение элемента, так и его индекс.
   - Синтаксис: `for index, value in enumerate(iterable)`.
   - В нашем случае 0используется для оценки, нопримпр `gardes`.
4. **Практическое применение**:
   - Итерируемся по `grades` с использованием `enumerate`.
   - Проверяем, если оценка `grades` меньше 60, заменяем ее на "не сдал".
   - Несмотря на то, что изменяем числовой спсок на строковый, програма работает корректно.
5. **Создание нового списка**:
   - Вместо изменения существующего списка, возможно создать новый, добавляя "сдал" или "не сдал" в зависимости от
     оценки.

### Упражнение - Игра камень ножницы бумага

1. **Запрос числа раундов**:
   - Запрашиваем у пользователя, сколько раундов он хочет сыграть.
2. **Основной цикл игры**:
   - Для каждого раунда происходит следующее:
     - Пользователь делает свой выбор из "Камень", "Ножницы", "Бумага".
     - Компьютер случайным образом выбирает свой вариант с использованием библиотеки `random`.
     - Сравниваются выборы и определяетя победитель раунда.
     - Ведется подсчет очков для пользователя и компьютера.
3. **Вывод итогов игры**:
   - Подводим итогии после всех раундов: выводим общий счет и объявляем победителя или ничью.

**Как реализовать**:

- Импортируем библиотеку `random` для случайного выбора.
- Определяем функции и переменные для храниния выбора, очков и результатов.
- Используем циклы и условные конструкции для обработки логики игры.

**Рекомендации**:

- Попробуйте самостоятельно реализовать игру, используя знания о циклах, условных операторах и функции ввода `input`.
- Для случайного выбора используйте `random.choice()`.

### While

Цикл while в программировании используется, когда необходимо повторять выполнение блока кода до тех пор, пока не станет
истинным заданное условие.

1. **Синтаксис**:
   - Структура цикла начинается с ключевого слова `while`, за которым следует условие.
   - Если условие истинно (true), выполняется тело цикла.
2. **Применение**:
   - Эот цикл полезен, когда количство повторений заранее неизвестно.
   - Он удобен для игр или программ, где необходимо ожидать ввода правильного значения от пользователя или выполнения
     определенного условия.
3. **Пример использования**:
   - Игра "Угадай число", где цикл ппродолжается до тех пор, пока пользователь не введет правильное число.
   - Пример кода:
   ```
   secret_number = 7
   guess = 0
   while geuss != secret_number:
       guess = int(input("Угадайте число от 1 до 10: "))
       if guess < secret_number:
           print("Загаданное число больше")
       elif guess > secret_number:
           print("Загаданное число менье)
   print("Поздравляю, вы угадали")
   ```
4. **Предостережения**:
   - Будьте внимательны, чтобы усовие цикла действитеельно могло стать ложным, иначе цикл станет бесконечным.
   - Избегайте ситуаций, которые могут привести к бесконечным петлям, например, `while true`, без предусмотренной
     остановки.
5. **Практические советы**:
   - Всегда проверяйте корректность условия выхода из цикла.
   - Варианты бесконечного цикла допустимы, но крайне редко и только в специфицированных условиях.

Цикл `while` позволяет гибко управлять логикой повторения и широко используется в программировании для множества задач.

### Упражнение - Проверка выбора

В этом уроке я улучшил игру "Камень, Ножницы, Бумага" так, чтобы она не завершалась из-за некорректного выбора
пользователя. Вместо этого я внедрил цикл, который будет запрашивать у пользователя правильный ввод до тех пор, пока им
не будет выбран верный вариант.

1. **Проблема**: Когда пользователь вводи неправильный выбор, приложение завершает работу.
2. **Цель**: Обеспечить возможность многократного выбора до тех пор, пока не будет плучен корректный ввод.
3. **Решение**: Используею цикл `while` для проверки ввода.
   - Инициализирую переменную `user_select` пустым занчением.
   - Запускаю цикл `while`, который продолжает запрашивать ввод, пока `user_select` не будет входить в список
     допустимых значений (choices).
   - Елси пользователь вводит некорректное значение, приложение снова запрашивает выбор.
   - Цикл продолжжается до тех пор, пока пользователь не выберет "Камень", "Ножницы" или "Бумага".

В результате, игра продолжает работу даже при некорректных вводах, улачшая взаимодействие с польователем и делая
процесс выбора более гибким.

### Break continue else

В этой лекции рассматривались ключевые слова `break`, `continue` и использование `else` с циклами в Python.

**Break**

- `break` завершает выполнение цикла реньше времени по определенному условию.
- Пример: цикл `for` перебирает числа от 0 до 100 и печатает их. Если `i` превышает 10, используем `break` для
  прекращения цикла.
- `break` останавливает выполнение текущего цикла и продолжает выполнение кода после него.

**Continue**

- `continue` прекращает текущую итерацию цикла и переходит к следующей.
- Пример: цикл `for` от 1 до 10, выводит только четные числа. Если число нечетное, `continue` пропускает оставшуюся
  часть итерации.
- отличие от `break`: `continue` не завершает цикл, а только текущую итерацию, продолжая со следующей.

**Else с циклами**

- `else` с циклами `for` и `while` используется, если цикл завершился естественным образам, без использования `break`.
- Пример: если цикл завершился без вызова `break`, выполняется блок кода под `else`.
- Это полезно для проверки, завершился ли цикл по `break` или естественным образом.

### Упражнение - Проверка спама

Цель:

Научиться использовать операторы `break`, `continue` и `else` на примере простого спам-фильтра для текстовых сообщений.

**Задача**

- Проверить массив сообщений на наличие слова "СПАМ".
- Остановить проверку и вывести "Найден СПАМ", если слово обнаружено.
- Пропускать длинные сообщения (более 20 символов).
- Уведомить о завершении проверки, если спам не обнаружен.

**Алгоритм**

1. **Итерация по сообщениям**:
   - Использовать цикл `for` для перебора каждого сообщения.
2. **Проверка на "&#x73;pa&#x6D;"**:
   - Если сообщение содержит слово "СПАМ":
     - Вывести "Найден СПАМ".
     - Испольовать оператор `break` для завершения проверки.
3. **Пропуск длинных сообщений**:
   - Если длина сообщения превышает 20 символов:
     - Использовать оператор `continue` для перехода к следующему сообщению.
4. **Вывод итогов**:
   - Если цикл завершился без использования `break`, использовать `else` для вывода "Проверка завершена, СПАМ не
     найден".

**Тестирование**

- Проверить сценарии, где сообщения содержат слово "СПАМ".
- Изменить слово "СПАМ" в сообщении, чтобы убедиться, что фильтр работает правильно.
- Проверить, что длинные сообщения не обрабатываются.

### Упражнение - Таблица умножения

В этом упражнении создавалась таблица умножения от 1 до 10 с использованием вложенных циклов в Python и особенностей
функцийй print.

1. **Вложенные циклы**:
   - Для создания таблицы умножения использум два вложенных цикла for.
   - Первый цикл (i) проходит числа от 1 до 10.
   - Внутри первого цикла, второй цикл (j) также проходит числа от 1 до 10.
2. **Функция print и f-string**:
   - Используем f-string для форматированного вывода, что позволяет вставлять переменные в строку.
   - Указываем ширину для выравнивания элементов, например, 4, чтобы все 0числа занимали одинаковое место.
   - Аргумент `end` позволяет избежать автоматического перехода на новую строку, задав пустую строку вместо переноса.
3. **Форматирование вывода**:
   - После каждого элемента end задается пустой строкой, чтобы не переносить строку.
   - После заавершения внутреннего цикла (j) вставляется пустой принт для переноса строки.

## Раздел 9. Функции

### None

В данной лекции я начал изучать функции в языке программирования Python и рассмотрел специальный тип данных - None. Вот
основные моменты:

1. **Функции в Python**:
   - Функции представляют собой блоки кода, которые можно переиспользовать в приложении.
   - Приложение на Python в основном состоит из функций или методов, которые реализуют различные части
     функциональности.
2. **Понятие None**:
   - None - это спциальныый тип, обозначающий пустоту.
   - Используется в следующих случаях:
     - Конда функция ничего не вернула.
     - Для указания, что переменная пока не инициализирована.
     - Когда аргумент функции не имеет значение по умолчанию.
3. **Создание и проверка None**:
   - Переменная может быть инициализирована как None.
   - Проверка, является ли переменная None, осуществляется с помощью оператора `is` (например, `x is None`).
   - Сравнение NAN с нулем, false или пустыми строками/списками всегда дает false, так как это разные сущности.
4. **Применение None**:
   - Дает возможность обозначать, что переменная или функция пока не имеет значения или не инициализирована.
   - Позволяет избегаь ошибок, связанных с неверной интерпретацией пустых значений.

### Объявление функции

Краткое введение в функции в программировании:

1. **Определение функции**:
   - Ключевое слово `def` используется для определения функции.
   - Следует за ним имя функции (например, `add_numbers`), которое должно отражать цель функции.
2. **Аргументы функции**:
   - Указаны в круглых скобках, следуют за именем функции.
   - Функция может иметь один, несколько или неограниченное число аргументов.
   - Аргументы можно типизировать, указывая их тип после двоеточия.
3. **Тело функции**:
   - Открывается двоеточием и состоит из одной или нескольких строк кода, описывающих действия функции.
   - Ключевое слово `return` используется для возврата результата из функции.
4. **пример простой фукнции**:
   - Создание функции, которая просто печатает "Привет" без аргументов.
   - Используется путем вызова функции по имени с пустыми скобками.
5. **КЕАПМИараметры и типизация**:
   - Добавление аргументов позволяет функции принимать входные данные (Например, `username`).
   - Можно (и рекомендуетсся) указывать типы параметров и возвращаемого значения.
   - Использование f-строк для включения аргументов в выходные данные.

### Выделение функций

На этом уроке я рассмотрел, как реорганизовать код моего приложения "Камень-Ножницы-Бумага" с использованием функций.
Основные этапы декомпозиции кода:

1. **Выделение функций**: Разбиваем код на логически обособленные части. Каждая функция должна выполнять одно действие,
   что делает код более читаемым и повторно используемым.
2. **Определение этапов**:
   - Получение ввода (input) от пользователя.
   - Обработка выбора прользователем в цикле.
   - Определение и вывод результата (выбор победителя и обновление счета).
3. **Функции на примере**:
   - **select_variant()**: Функция для обработки и возвращения выбора пользователя.
   - **comute_game_result()**: Рассчитывает результат раунда и возвращает модификаторы для счета.
   - **print_result()**: Выводит итоговый счет после всех раундов.
4. **Аргументы и возвраты**: Каждой функции передаются необходимые параметры, и она возвращает значения, которые влиюят
   на логику игры.

### Область видимости

#### Область видимости в Python и порядок поиска переменных

**Область видимости (Scope)**

- **Определение**: Область кода, в которой переменная доступна для использования.

**Порядок поиска переменных (LEGB)**

1. **L (Local)**: Внутри функции.
   - Сначала Python ищет переменные внутри текущей функции.
   - Пример: Если в функции объявлена `x = 1`, то при вызове `print(x)` Python использует локальную `x`.
2. **E (Enclosing, или Замыкание)**: Вложенные функции.
   - Если переменная не найдена локально, Python ищет в функциях, охватывающих текущую функцию.
   - Это актуально для функций, возвращающих другие функции.
3. **G (Global)**: Глобальная область.
   - Если переменная отсутствует в локальной и замыкающей областях, поиск идет в глобальной.
   - Пример: Если вне функции объявлена `x = 20` и пытаемся использовать `x` в функции, будет выбрана глобальная `x`.
4. **B (Built-in)**: Встроенные функции и объекты.
   - Если переменная не найдена ни в одной из предыдущих областей, Python обращается к встроенным функциям.
   - Пример: Если переопределить `print`, Python будет искать новую реализацию, а не встроенную.

**Примеры**

- **Локальная область видимости**:

```
def my_function():
    x = 10
    print(x) # Здесь x  доступен.
my_function()
print(x) # Ошибка: x не определен в глабальной области
```

- **Глобальная область видимости**:

```
x = 20
def show():
    print(x) # Используется глобальная x
show()
```

**Важные замечания**

- **Порядок объявления переменных**: Переменные должны быть определены до их использования.
  - Например, если `show` вызывается до объявления `x`, возникнет ошибка.
- **Глобальные переменные**: Доступны в функциях после их объявления, но использование глобальных переменных может
  привести к трудноконтролируемым ошибкам.
- **Переопределение встроенных функций**:
  - Это возможно, но не рекомендуется. Например, переопределение `print()` может вызвать проблемы с выводом.

Эти принципы помогут понять, как Python ищет и использует переменные, что важно для написания корректного кода.

### Упражнене - Калькулятор

В этой лекции я создал функцию `calculate` для выполнения базовых арифметических операций. Вот основные шаги создания
функции:

1. **Определение функции**:
   - Описываем функцию как `def calculate(a: float, b: float, operation: str)`, принимающую два числаи строку-операцию.
2. **Определение логики работы**:
   - Используем конструкцию `match-case` для выбора операции (в Python 3.10 и выше).
   - Прописываем варианты:
     - Если операция "+" - возвращаем сумму `a + b`.
     - Если операция "-" - возвращаем разность `a - b`.
     - Если операция "_" - возвращаем произведение `a _ b`.
     - Если операция "/" - проверяем, что делитель `b` не равен нулю. Возвращаем частное или сообщение об ошибке
       "Ошибка: деление на ноль".
3. **Обработка неизвестной операции**:
   - Возвращаем сообщение "Неизвестная операция", если передана неподдерживаемая операция.
4. **Тестирование функции**:
   - Проводим тесты, вызывая `calculate` с различными значениями и проверяя корректность результатов.

### Docstring

Введение

- Обсудим, что такое докстринг и его важность.
- Докстринг - это строка документации, описывающая содержание функций, классов или модулей.
- Помогает разаработчикам ориентироваться в коде.

**Структура и стиль**

- Докстринг должен начинаться с заглавной буквы и не содержать точку в конце первой строки.
- Первая строка - краткое описание, далее - детальное объяснение.
- Докстринг можно структурировать с использованием `:param` и `:return`.

**Пример использования**

- Пример использования докстринга для функции, выполняющей математическую операцию.
- После добавления докстринга IDE показывает описание функции.

**Настройка поведений**

- Конфигурация файла `pylintrc` для управления предупреждениями о пропущенных докстрингах.
- Позволяет отключать ненужные сообщения, такие как C0114, через настройки `disable`.

**Рекомендации**

- Используйте докстринги для сложных функций.
- Если функция проста и ее название понятно, докстринг может быть необязателен.
- Настраивайте правила использования докстринга в зависимости от договоренностей в команде.

### Literals

Сейчас будет разговор о том, как использовать литералы для улучшения типизации в Python. Литералы помогают более точно
указывать типы переменных в коде.

1. **Что такое литерал**:
   - Литерал - это конкретное значение, например, буква илисимвол, который используется как есть.
   - Пример: если переменная `a` равна "a", то это литерал.
2. **Типизация с помощью литералов**:
   - При использовании литералов в переменных, Python IDE может подсказывать точные типы, но под капотом они остаются
     строками или числами.
   - Использование литералов помогает болееточно описывать возможные значения переменных в функциях.
3. **Пример построчного использования**:
   - Например, для функций калькулятора можно определить операцию как литерал, чтобы она принимала
     только "+", "-", "\*", "/".
4. **Как использовать библиотеку `typing`**:
   - Импортируйте `Litreal` из библиотеки `typing`.
   - Укажите возможные значения, например: `operation: Literal["+", "-", "*", "/"]`.
5. **Приемущества использования литералов**:
   - Код становится более точным и понятным.
   - Исключает возможность передачи неверного значения на этапе написания кода.
   - Облегчает поддержку и чтение кода в будущем.

### Star arguments

В этой лекции я разобрал работу с неограниченным числом аргументов в функциях с помощью использования звездочки (\*) и
параметра "args".

1. **Использование функции print()**:
   - `print()` может принимать любое количество аргументов (1, 2, 3 и более).
   - Она работает независимо от количества переданных аргументов.
2. **Аргументы функции**:
   - Чтобы функция принимала неограниченное количество аргументов, используем `*args`.
   - `args` переменная содержит все переданные аргументы в виде кортежа (tuple).
3. **Пример с функцией для среднего значения**:
   - Для расчета среднего используем `sum(args)` для суммы и `len(args)` для лдины кортежа.
   - Например, функция `avg` корректно вычисляет среднее для любого количества чисел.
4. **Другие аргументы с `*args`**:
   - Наряду с `*args` можнжо использовать другие именованные аргументы.
   - Пример функции `print_data()`, где первый аргумент - `name`, а остальные строки передаются как `*data`.

### Значение по умолчанию

В этом уроке я узнал как использовать опциональные аргументы в фукнциях, задавая значения по умолчанию. Опциональные
аргументы позволяют функции работать даже при отсутствии некоторых входных данных.

1. **Создание функции с опциональными аргументами**:
   - Создадим функцию `ext`, которая возводит числов степень. Основные параметры: число (`float`) и степень (`float`).
   - Типизацию в Python можно не использовать, но оа помогает избежать ошибок, указывая на типы входных данных
     (аргументов) и выходных данных (результата).
2. **Значения по умолчанию**:
   - Чтобы избежать ошибок при отсутствии переданого аргумента, можно задать значение по умолчанию (напримр, степень по
     умолчанию равна 2, чтобы число возводилось в квадрат).
   - С использованием значения по умолчанию функция может работать при передаче только одного аргумента.
3. **Правила использования опциональных аргументов**:
   - Опциональные аргументы должны следовать за обязательными.
   - Нельзя задать значение по умолчанию для аргумента, за которым следует обязательный аргумент.
4. **Примеры**:
   - Пример с вызовом `exp(2, 3)` возвращает 8 - без ошибок, так как оба аргумента переданы.
   - Пример с вызовом `exp(2)` использует степень по умолчанию и возвращает 4.
5. **Использование в других функциях**:
   - Как в примере с функцией `print`, которая имеет опциональные аргументы `separator` и `end`, так и в функции `exp`
     можно использовать дефолтные значения для гибкости в вызовах.

Такая настройка опциональных аргументов и дефолтных значений повышает удобство и гибкость использования функций.

### Именованные аргументы

1. **Функция print и ее параметры**:
   - Функция `print` принимает несколько аргументов, среди которых `separator` и `end`.
   - Для изменения только одного из этих параметров используется именованный аргумент.
2. **Порядок и занчение аргументов**:
   - Порядок аргументов имеет значение. Если поменять местами параметры, то изменится и результат.
   - Для избежания прутаницы используйте именованные аргументы. Это позволяет явно указыть, какой параметр к какому
     аргументу относится и избежать неправильной передачи значений.
3. **Пример с функцией возведения в степень**:
   - Создаю функцию, добавляю аргумент `multiplier` с умолчанием 1.
   - Можно задать `vultiplier` через именованные аргументы, чтобы увеличить результат умножения после возведения в
     степень.
4. **Гибкость именованных аргументов**:
   - Именованные аргументы позволяют удобно передавать только нужные значения, не соблюдая строгий порядок.
   - Они полезны, когда нужно изменить параметр, находящийся после параметра с умолчанием.
5. **Использование в пользовательских функциях**:
   - Разберем пример с функцией `print_data`, где `separator` может быть задан 0явно.
   - Такое использование позволяет четко указать, какое значение к какому параметру относится, что исключает ошибки
     впорядке передачи аргументов.
6. **Опциональные аргументы и их гибкость**:
   - Именованные аргументы дают возможность передавать опциональные параметры, находящиеся после других опциональных
     или после параметров, принимающих неограниченное количество значений.
   - Важно, что они позволяют делать код более читаемым и гибким.

### Упражнение - Генерация пароля

Для создания генератора паролей предлагается выполнить следующие шаги:

1. **Определение функции**:  
   Определить функцию `generate_password`, принимающую аргументы:
   - `length`: длина пароля (тип int, по умолчанию 8).
   - `use_symbols`: использовать ли символы (тип bool, по умолчанию True).
2. **Валидация длины**:  
   Проверить если `length` меньше 3, вернуть пустую строку.
3. **Форматирование пула символов**:
   - Импортировать моуль `string` и использовать его `ascii_letters` и `digits` для букв и цифр.
   - Определить вручную символы: `! @ # $ % & * ?`.
   - Объединить буквы, цифры и (если `use_symbols` True) символы в единый pool.
4. **Генерация пароля**:
   - Импортировать модуль `random`.
   - Создать пустой список `password_chars`.
   - Заполнять `password_chars` с помощью `randeom.choice(pool)`, пока его длина не станет равной `length`.
5. **Возврат резултата**:
   - Объединить `password_chars` в строку с помощью `join()` и вернуть.
6. **Тестирование**:
   - Сгенерировать пароли с разными параметрами (например, с длиной 10 и без символов).
   - Вывести результаты в консоль.

## Раздел 10. Sets и словари

### Словари

Словари (Dictionaries)

- **Определение и особенности**:
  - Словари хранят данные в виде пар "ключ-значение".
  - В отличие от списков, где доступ осуществляется по индексу, в словарях осуществряется по ключу.
  - Ключи должны быть хэшируемыми (например, строки, числа, булевые значения, кортежи).
- **Хэш-таблицы**:
  - Основой словарей является хэш-таблица, позволяющая быстро находить элементы.
  - Время доступа к элементу ссловаря - О(1), что не зависит от числа элементов в словаре.
  - При одинаковых хэшах различных ключей используется дополнительный сдвиг, решающий коллизии.
- **Создание словарей**:
  - Через фигурные скобки: `{"name": "Андрей", "age": 55}.
  - С использованием функции `dict`: `dict(name="Андрей", age=55)`.
  - Используя список пар "ключ-значение": `dict([("name", "Андрей"), ("age", 37)]).

### Доступ к значениям

В этой лекции я рассматривал работу со словарями в языках программирования, используя Python в качестве примера.

1. **Получение значения по ключу**: Использую квадратные скобки, записывая имя ключа, чтобы получить значение,
   связанное с этим ключом.
2. **Изменение значения**: Аналогично полученоию, просто присваиваем новое значение интересующему ключу.
3. **Добавление нового ключа**: Если ключ отсутствует, при присвоении значения создается новая пара ключ-значение.
4. **Удаление ключа**: Используем метод `pop()`, чтобы удалить ключ и получить значение, которое было связано с ним.
5. **Безопасное получение значения**: Использую метод `get()`, чтобы избежать ошибок доступа к несуществующему ключу.
   Можно задать дефолтное значение, которое будет возвращено, если ключ отсутстсвует.
6. **Проверка наличия ключа**: Использую конструкцию `in` для проверки существования ключа.

Основные функции и методы:

- `user[key]` для получения и изменения.
- `user.get(key, default)` для безопасного получения.
- `user.pop(key)` для удаления.
- `key in user` для проверки наличия ключа.

### Упражнение - Меню приложения

На этом уроке я создал меню для приложения управления паролями. Основные цели:

1. **Создание меню**: Приложение должно при запуске показывать меню с опциями для пользователя:
   - Показать пароли.
   - Добавить пароль.
   - Удалить пароль.
   - Обновить пароль.
   - Выход.
2. **Функция меню**:
   - Создал функцию `show_menu`, которая отображает меню пользователю.
   - Испольовал бесконечный цил `while True` для постоянного показа меню до тех пор, пока пользователь не выберет пункт
     "Выход".
3. **Обработка выбора пользователя**:
   - Ждем ввода пользоватея и преобразуем его выбор в число.
   - Используется структура `match-case` (или аналогичная) для обработки выбора:
     - `case 1`: Показывются пароли.
     - `case 2`: Добавляется пароль.
     - `case 3`: Удаляется пароль.
     - `case 1`: Обновляется пароль.
     - `case 1`: Выход из приложения.
4. **Проверка работы меню**:
   - Запуск приложения, выбор различных пунктов меню для проверки их корректной работы.
   - Подтверждение, что приложение позволяет выбирать пункты и выходить по запросу.

Эта структура является основой для дальнейшего добавления полезных функций в следующих уроках.

### Упражнение - Управление паролями

Резюмирую процесс создания простого приложения для управления паролями с использованием словаря в Python:

1. **Инициализация**: Создается пустой словать `passwords` для хранения паролей. Ключами будут 0домены или названия
   приложений, а значениями - пароли.
2. **Добавление Пароля (add_password)**:
   - Запрашивается у пользователя домен и пароль.
   - Если пароль пустой, генерируется его автоматически.
   - Сохраняются домен и пароль в словарь.
3. **Показ Паролей (show_passwords)**:
   - Просто выводится содержимое словаря, показывая домены и связанные с ними пароли, можно улучшить формат вывода.
4. **Удаление Пароля (delete_password)**:
   - Запрашивается у пользователя домен.
   - Удаляется связанный с доменом пароль из словаря.
   - В случае несуществующего домена, выводится сообщение об отутствии пароля.
5. **Обновление Пароля (update_password)**:
   - Запрашивается у пользователя домен и новый пароль.
   - Проверяется существование домена в словаре.
   - Если домен существует, обновляется пароль, в противном случае сообщается об отсутствии домена.
6. **Улучшения**:
   - Обработка неправильного ввода пользоватея (например, при преобразовании ввода в число).
   - Оптимизируется код с использованием отдельных функций для повторяющихся действий (например, ввод и генерация
     паролей).
7. **Заключение**: Несмотря на то, что парол хранятся только в памяти (и теряются при завершении программы), это
   хорошее вводное упражнение для практики с использованием словарей в Python.

### Итерация по словарю

Итерация по словарям в Python может выполнятсья тремя способами:

1. **По ключам**:
   - Используя цикл `for`, можно перебиравть только ключи словаря. Например:
   ```
   for key in user:
       print(key)
   ```
   - При этом переменная `key` последовательно принимает знаяения кождого ключа (например, `age`, `name`).
2. **По ключу и значению (items)**:
   - Используя метод `items()` у словаря, можно перебирать пары "ключ-значение":
   ```
   for key, value in user.items():
       print(f"{key}: {value}")
   ```
   - Позволяет одновременно использовать и ключ, и соотвествующее ему значение.
3. **Только по значения. (values)**:
   - Используя метод `values()`, можно перебирать только значения словаря:
   ```
   for value in user.values():
       print(value)
   ```

С версии Pyth9on 3.7 сохраняется порядок добавления элементов в словарь. Это значит, что порядок, в котором вы
добавляете элементы, будет соответствовать порядку их итерирования.

Эти методы помогут эффективно работатьб со словарями, например, в таких задачах, как создание генератора паролей.

### Упражнение - Вывод паролей

На этой лекции я рассмотрел, как можно улучшить вывод паролей из словаря, применяя итерирование и форматирование, чтобы
сделать его более читабельным и организованным в виде таблицы.

1. **Задача**: Сделать вывод паролей из словаря более красивым и структурированным.
2. **Методы форматирования**:
   - использование метода `ljust`для добавления пробелов справа от строки, чтобы уравнять их длину и обеспечить
     выравнивание таблички.
   - Альтеранативно, можно применять форматирование строк.
3. **Структура кода**:
   - Сначала распечатка заголовка таблицы с использованием `ljust` для выравнивания.
   - Разделение заголовков и данных вертикальной чертой (двоеточием) и пробелами для визуальной структуры.
   - Итерация по словарю паролей с использованием метода `items()` для получения ключей и значений.
   - Вывод каждого ключа и значения с применением `ljust` для выравнивания.
4. **Типизация**:
   - Указание типа словаря `dict[str, str]` для упрощения работы с методами строк.
5. **Практика**:
   - добавление и отображение нескольких паролей с демонстрацией изменений по длине выводимого контента.
6. **РПезультат**:
   - Получение наглядной таблицы, где каждый ключ пароля и его значение организованно и визуально четко представлен.

### Sets (Множества)

#### Введение в мноества (set) в Python

##### Определение и характеристкики

1. **Множество** (set) - это неупорядоченная коллекция уникльных элементов.
2. Под капотом множество реализуется с использованием **хэш-таблицы**.
3. Множества хранят **только уникальные значения** - дубликаты автоматически удаляются.

##### Отличия от списков (list)

- **Списки** упрорядочены и могут содержать дубликаты.
- **Множества** неупорядочены и не могут содержать дубликаты.
- Списки могут содержать вложенные списки, множества - таолько хэшируемые элементы.

##### Особенности

- Быстрая проверка принадлежности элемента - доступ с временной сложностью O(1).
- Изменяемый тип данных: возможны операции добавления и удаления элементов.

##### Создание множеств

1. **Пустое множество**: `set()`.

```
empty_set = set()
```

2. **Множество с элементами** (через фигурные скобки):

```
sapmple_set = {1, 2, 3, 4, 5}
```

- При добавлении повторяющихся значений они автоматически удаляются:

```
duplicate_set = {1, 2, 2, 3}  # Останутся только 1, 2, 3
```

##### Преобразование других коллекций в set

- Из списка:

```
list_to_set = set([1, 2, 2, 3, 4])
```

- Из кортежа:

```
tuple_to_set = set((1, 2, 3, 3))
```

##### Практическое использование

- Выполняйте операции создания и преобразования с учетом уникальности и неупорядоченности элементов.
- Эффективно используйте множество для операций, требующих проверки принадлежности.

Теперь, зная основы множеств, перехожу к рассмотрению операйий, которые доступны для этих структур данных.

### Операции с множествами

В этой лекции рассмотрены основные операции над множествами (set) в Python, такие как добавление, удаление и проверка
наличия элементов, а также инерирование по множеству.

1. **Создание множества**:
   - Создаем множества `s` с элементами 1, 2, 3, 4.
2. **Добавление элементов**:
   - Используем метод `add` для добавления одного элемента.
   - Метод `update` позволяет добавить несколько элементов из любого итерируемого объекта, например, списка или
     кортежа.
3. **Удаление элементов**:
   - `remove`: удаляет указанный элемент. Если элемента нет, возникает ошибка `KeyError`.
   - `discard`: безопасно удаляет элемент, не вызывая ошибки, если элемент отсутствует.
   - `pop`: удаляет и возвращает первый элемент по настройке этого множества (в реальности - по внутренней
     хэш-таблице).
4. **Проверка наличия элемента**:
   - Оператор `in` используется для проверки, находится ли элемент в множестве.
5. **Итерирование по множеству**:
   - Для итерирования применяем цикл `for`, как и для списков.
6. **Особенности методов**:
   - `pop` возвращает удаленный элемент, тогда как `remove` и `discard` ничего не возвращают.

Эти возможности делают работу с множествами в Python гибкой и эффективной для многих задач.

### Uninon differece и другие

Сегодня я изучил операции над множествами в Python, используя основы теории множеств. Посмотрим на основные операции:

1. **Объединение (Union)**:
   - Создает новое множество, содержащее все уникальные элементы из обоих множеств.
   - Использование: `a.union(b)` или `a | b`.
   - Пример: Объединение `{1, 2, 3}` и `{3, 4, 5}` даст `{1, 2, 3, 4, 5}`.
2. **Пересечение (Intersection)**:
   - Получает элементы, которые есть в обоих множествах.
   - Использование: `a.intersection(b)` или `a & b`.
   - Пример: Пересечение `{1, 2, 3}` и `{3, 4, 5}` даст `{3}`.
3. **Разность (Difference)**:
   - Показывает уникальные элементы первого множества, которых нет во втором.
   - Использование: `a.difference(b)` или `a - b`.
   - Пример: Разность `{1, 2, 3, 4}` и `{3, 4, 5}` даст `{1, 2}`.
4. **Симметричная разность (Symmetric Difference)**:
   - Найти элементы, которые находятся в одном из множеств, но не в обоих.
   - Использование: `a.dymmetric_difference(b)` или `a ^ b`.
   - Пример: Симметричная разнеость `{1, 2, 3}` и `{3, 4, 5}` даст `{1, 2, 4, 5}`.

Эти операции над множествами помогут вам управлять и манипулировать данными в Python, решая различные задачи. Не нужно
глубокое знание теории множеств; достаточно понимать, как использовать эти операции для практических задач. Двигаюсь
дальше.

### Упражнение - Посетители конференции

В этом упражнении я рассмотрел практическое применение сетов (множеств) в реальной задаче, сыязанной с выявлением
уникальных посетителей на мероприятии. Основные шаги включают:

1. **Идентификация уникальных посетителей**:
   - Созадем сеты для каждого дня мероприятия, чтобы получить списки уникальных посетителей. Это позволит избавиться от
     дублирующих записей.
2. **Расчет покзаателей**:
   - Подсчитываю общее количество посетителей и количество уникальных посетителей для каждого дня.
3. **Анализ посещаемости**:
   - Определяем, кто посетил оба дня мероприятия (пересечение мноржеств).
   - Идентифицируем тех, кто посетил только первый день и только второй день (разность множеств).
   - Выясняю, кто был только в один из дней (симметричная разность).
4. **Пример анализа**:
   - Пример содежржит конкретные идентификаторы посетителей и результаты анализа, такие как количество уникльных и
     общих посещений, а также идентификаторы, соответствующие различным категориям (например, тлько первый день, оба
     дня).

Этот процесс демонстрирует, как сеты могут эффективно использоваться для обработки и анализа данных о посещаемости,
обеспечивая простоту в использовании и понимании.

### Сравнение множеств

На этом уроке я узнал, как сравнивать множества и использовать некоторые полезные методы, такие как проверка на
подмножество и надмножество, очистка и копирование множеств.

1. **Подмноежство и надмножество**:
   - Чтобы проверить, является ли одно множество подмножеством другого, используем метод `issubset()`. Например, если
     множество `a` содержит элементы {1, 2}, а множество `b` - {1, 2, 3}, то `a` является подмножеством `b`, т.к. все
     элементы `a` присутствуют в `b`.
   - Для проверки, что одно множество является надмножеством другого, используем метод `issuperset()`. Например, `b`
     является надмножеством `a`.
2. **Сравнение множеств**:
   - Множества мнжно преверять на равенство независимо от проядка элементов. Например, множества {1, 2, 3} и {3, 1, 2}.
     равны, поскольку содержат одинаковые элементы.
3. **Полезные методы**:
   - `clear()`: очищает мноежство, оставляя его пустым.
   - `copy()`: создает копию множества. Копии можно сравнивать с оригиналом, и они будут равны.

Таким образом, я научился сравнивать множества, проверять их на подмножества и надмножества, а также использовать
некоторые вспомогательные методы для работы с множествами.

### Frozenset

Лекция посвящена особенностям использования коллекции данных в Python - frozenset.

1. **Определение frozenset**:
   - forzenset - это неизменяемая версия Set.
   - Неизменяемость позволяет защищать данные от изменений после создания.
2. **Создание frozenset**:
   - Используется функция `frozenset()`.
   - Аргументом выступает любой итерируемый объект, который преобразуется в frozenset.
3. **Особенности frozenset**:
   - Нельзя добавить элемент методом `add`.
   - Нет методов `pop`, `remove` для удаления элементов.
   - Неизменяемость обеспечивает защиту структуры данных.
4. **Операции с frozenset**:
   - Можно сравнривать с другими коллекциями frozenset.
   - Поддерживаются операции объединения, пересечения и другие, как у обычных множеств.
   - результат таких операций также - неизменяемый frozrnbset.
5. **Применение**:
   - Полезен для защиты данных от изменений.
   - Подходит для случаес, когда важна неизменяемость набора данных.
6. **Методы работы с frozenset**:
   - `union` и `subset` для операций с множествами.
   - `copy` для создания копии, однако копия будет неизменяемой.

Итог: frozenset - неизменяемый тип множества в Python, используемый для обеспечения постоянства данных после их
создания.

### Упражение - Провекра документов

В этом упражнении я рассмотрел задачу проверки набора документво для подачи на визу. Я проверяю:

1. **Наличие обязательных документов**:
   - У пользователя должны быть все документы из списка обязательных (паспорт, ИНН, СНИЛС).
   - Проверяется, является ли набор пользовательских документов (user_docs) подмножеством обязательных (required_docs).
2. **Сравнение наборов документов**:
   - Сравниваются два набора документов: обязательные и предоставленные пользователем.
   - Для точного сравнения необходимо испольовать преобразование наборов документвов `forzenset`.
3. **Вывод лишних документов**:
   - Определить какие документы есть у пользователя, но не входят в обязательных список.
   - Выполняется путем вычитания обязательных документов из пользовательских.

В ходе урока я использовал `set` и `frozenset` для операций с множествами. Привел пример, как преобразование в
`frozenset` нужно только при проверке на равенство, но не требуется для операций с подмножествами или вычитанием.

## Раздел 11. Функции высшего порядка

### Функции высшего порядка

В этом разделе я изучаю функции высшего порядка.

1. **Определение функций высшего порядка**:
   - Это функции, которые принимают другие функции как аргументы или возвращают функции как результаты.
   - В Python функции являются объектами, поэтому их можно передавать и возвращать, как и любой другой объект.
2. **Переход от строгой типизации к стандартной**:
   - Из-за сложности типизации функций высшего порядка я перейду от строгой типизации Pylint к стандартной, чтобы
     упростить работу на начальном уровне.
3. **Пример функции, принимающей другую функцию**:
   - Функция `apply` принимает функцию и значение, применяет функцию к значению и возвращает результат.
   - Пример: функция `square`, которая возвращает квадрат числа, может быть передана в `apply`.
4. **Рассмотрение примера функции, возвращающей функцию**:
   - Функция `make_adder` создает и возвращает функцию, которая добавляет заданное число.
   - Пример: вызов `make_adder(5)` создаст функцию, которая прибавляет 5 к переданному аргументу.
5. **Итог**:
   - Функции высшего порядка позволяют писать более универсальный и адаптируемый код.
   - Я использовал просую типизацию и примеры для лучшего понимания.

### Lambda

#### Лямбда-функция в Python

1. **Что такое лямбда-функция**?
   - Это анонимная функция, которая позволяет создавать функции без имени.
   - Удобно использовать в функциях высшего порядка, где не нужно объявлять отдельную функцию.
2. **Особенности и ограничения**:
   - Лямбда-выражение должно помещаться в одну строку.
   - После ключевого слова `lambda` следуют аргументы, затем двоеточие и выражение.
   - Ограничение одной строки связано с синтасисом Python.
3. **Пример использования**:
   - Обычная функция:
   ```
   def square(x):
       return x * x
   ```
   - Лямбда-функция:
   ```
   square_lanbda = lambda x: x * x
   ```
   - Лямбда-функция размещается в одной строке, и ее можно сразу использовать.
4. **Практическое применение**:
   - Использование в функции высшего порядка, например, `apply`, которая принимает функцию и значение, и применяет
     функцию к значению.
   - Например:
   ```
   apply(lambda x: x + 100, 5)
   ```
   - Еще один пример для преобразования текста:
   ```
   apply(lambda s: s.upper(), "hi")
   ```
5. **Ограничения лямбда-функций**:
   - Нельзя использовать сложные конструкции, такие как циклы или условные операторы `if`.
   - Лямбда-функции обычно используются для простых операций.

#### Заключение

Лямбда-функции в Python позволяют сократить код, когда не требуется создавать именованные функции, особенно полезны в
фукнциях высшего порядка, но имеют ограничения в сложности выражений.

### Map

На этом уроке рассмотрены функции высшего порядка в Python, которые помогают работать с изменением списков, в
частности функция `map`. Вот основные моменты:

1. **Функция `map`**:
   - Возвращает итератор.
   - Принимает на вход функцию и список элементов.
   - Применяет функцию к каждому элементу списка.
2. **Пример использования `map`**:
   - Задача: возвести каждый элемент списка чисел в квадрат.
   - Без `map`: используется цикл для добавления каждого квадрата в новый список.
   - С `map`: создается итератор через `map`, применяя функцию `square` к каждому элементу списка. Итератор затем
     преобразуется в список.
3. **Оптимизация с помощью `lambda`**:
   - Вместо отдельного объявления функции `square`, используется `lambda` для краткости: `lambda x: x * x`.
4. **Работа с несколькими списками**:
   - `map` может принимать несколько списков для обработки.
   - Пример: сложение двух списков элемент-wise с использованием `lambda x, y: x + y`.
5. **Преимущества `map`**:
   - Уменьшает объем кода.
   - Эффективное использование памяти, так как `map` возвращает итератор, а не список.
   - Позволяет обрабатывать несколько списков одновременно.

### Упражнение - Нормализация данных

1. **Проблема**:
   - Имеются хаотичные данные пользователей: имена с разными регистрами и пробелами, возраст представлен как строка с
     пробелами.
   - Необходимо нормализовать данные для дальнейшего использования.
2. **Цель**:
   - Привести данные пользователей к единому виду:
     - Убрать пробелы и сделать первую букву имен большой.
     - Преобразовать возраст в целое число.
3. **Решение**:
   - Определить список пользователей, где каждый элемен - словать с ключами "name" и "age".
   - Написать функцию `normalize`, котороая будет обрабатывать один элемент списка.
4. **Функция `normalize`**:
   - Принимает пользователя (словарь) как входной аргумент.
   - Для ключа "name":
     - Убирает пробелы методом `lstrip()`.
     - Преобразует первую букву в верхний регистр методом `capitalize()`.
   - Для ключа "age":
     - Убирает пробелы методом `lstrip()`.
     - Конвертирует строку в целое число `int`.
5. **Использовение map**:
   - Применяем функцию `normalize` ко всем элементам списка с помощью функции `map()`.
   - Преобразуем результат `map` в список `normalized_users`.
6. **Результат**:
   - Получаем нормализованный список пользователей с корректными именами и возрастом.

### Filter

Сегодня я рассмотрел встроенную функцию `filter`, котороая помогает отфильтровывать элементы списка на основе заданного
условия.

1. **Задача**: Допустим, у нас есть список чисел: 10, 15, 20, 25, 30. Мы хотим оставить тлько четные числа.
2. **Классичесукий подход**:
   - Создаем овый список `evens`.
   - С помощью цикла `for` проверяем каждое число.
   - Если число делится на 2 без остатка, добавляем его в `evens`.
3. **Использование функции `filter`**:
   - `filter` принимает два аргумента: функция и итерация (например, список).
   - Функция должна возвращать `True`, если элемент нужно оставить, и `False`, если нет.
   - Определяем функцию `is_ever(x)`, которая проверяет, является ли число четным.
   - Применяем `filter`, преобразуем результат в список и выводим четные числа.
4. **Оптимизация с использованием лямбда-функции**:
   - Вместо отдеьной функции можно использовать лямбда-выражение для краткости.
   - Применяем `filter` с лямбда-функцией для получения четных чисел.
5. **Использование List Comprehension**:
   - Генерируем список на основании условия через List Comprehension.
   - `even_comp = [x for x in nums if x % 2 == 0]` - этот синтиаксис аналогичен `filter` и дает тот же результат.

Каждый метод приводит к одному и тому же результату: список из четных чисел. Выбор между ними зависит от предпочтений
по читабельности и удобству использования в конкретной ситуации.

### Упражнение - Поиск заказов

Сегодня я рассмотрел, как применить знания о фильтах данных на проктике с помощью реальной задачи. Представим, что у
меня есть информация о пользователях, которые покупают курсы: их идентификаторы, сумма покупок и статус платежа. Моя
задача - найти всех пользователей, чьи заказы превышают 100 и имеют статус "paid", чтобы отпрвитиь им спецпредложние.

1. **Постановка задачи**:
   - Найти пользователей, заплативших более 100 с подтвержденным платежом.
   - Подготовить для них сообщение с предложением.
2. **Решение задачи**:
   - Используем функцию фильтрации данных.
   - Можно применить один или несколько фильтров.
3. **Пример решения**:
   - Простой способ: применяем одну лямбда-функцию для фильтрации.
   - Условия фильтрации: статус "paid" и сумма > 100.
   - Код: `filtered_orders = list(filter(lambda order: order['status'] == 'paid' and order['amount'] > 100, orders))`.
4. **Альтернативные подходы**:
   - Можно использовать два фильтра подряд, но это менее эффективно по памяти.
5. **Результат**:
   - Фильтр верно обрабатывает данные, остаются пользователи с необходимыми условиями.
   - Пример: Пользователи Андрей, Станислав, Екатерина с соответстующими суммами.

Таким образом, я эффективно применил фильтры и отфильровал данные для достижения цели.

### Reduce

1. **Введение в фнкуцию Reduce**
   - Функция `reduce` импортируется из модуля `functools`.
   - Она используется для преобразования списка или другого итерируемого объекта в одно значение.
2. **Сумма чисел с использованием reduce**
   - В базовом случае можно использовать встроенную функцию `sum` для нахождения сумммы чисел.
   - Однако, можно использовать `reduce` для более сложных операций, когда нет подходящей встроенной функции.
   - Пример использования цикла для суммирования чисел путем накопления значений.
3. **Использование reduce**
   - Импортируем `reduce` из `functools`.
   - Определяем функцию или используем `lambda`, которая принимает два аргумента и возвращает их сумму.
   - Применяем `reduce`, чтобы пройти по итерируемому объекту и накопить итоговое значение.
4. **Конкатенация строк через reduce**
   - Пример, когда простая сумма не подходит (например, конкатенация строк).
   - Использование `reduce` для создания предложения из списка слов.
   - Применение `lambda` для сложения строк.
5. **Понятие a и b в lambda-выражении**
   - `a` - начение аккумулятора, `b` - следующий элемент последовательности.
   - Пример с начальным значением: начальное значение можно задавать дополнительно в `reduce`.
6. **Примеры выполнения и итог**
   - Примеры, как `reduce` работает под капотом, начиная с начального значения и аккумулируя результаты.
   - Возможность задания начального значения вручную для управления результатами.
7. **Заключение**
   - `reduce` полезен в случаях, когда нужна комлексная обработка итерируемых объектов.
   - Он позволяет аккумулировать результаты операций, которые нельзя выполнить с помощью встроенных функций.

### Упражнение - Статистика заказов

В этом упражнении я учился применять функцию `reduce` для обработки данных о заказах в магазине электроники. Цель
задачи - вычислить общее количество проданных товаров и общую сумму заказов за день, используя данные, хранящиеся в
словарях.

#### Шаги решения

1. **Струткура даных**:
   - Данные о заказах хранятся в словарях. Каждый заказ содержит идентификатор, пользователя, и `items` - список
     покупок. Каждый элемент списка (item) также является словарем, содержащим информацию о товаре и его цене (price).
2. **Создание функции `aggregate`**:
   - Функция `aggregate` принимает два параметра:
     - `accumulator` - это словарь, содержащий текущие общие значения по сумме заказов и количеству товаров.
     - `order` - текущий обрабатываемый заказ (словарь).
   - Инициаизирую `accumulator` как словарь с ключами `total_price` и `total_items`, значения которых изначально равны
     нулю.
3. **Обработка заказа**:
   - Для вычисления суммы для каждого заказа, суммирую цены товаров из `items` внутри заказа.
   - `order_sum` - сумма цен всех товаров в текущем заказе.
   - `order_count` - количество товаров в текущем заказе (длина списка `items`).
4. **Агрегация данных**:
   - В каждой итерации обновляю значения `accumulator`:
     - Обновляю `total_price` добавлением текущего `order_sum`.
     - Обновляю `total_items` добавлением `order_count`.
5. **Применение `reduce`**:
   - Использую функцию `reduce`, передавая в нее мою функцию `aggregate`, данные о заказах и начальные значения
     (нулевые значения для `total_price` и `total_items`).
   - Импортирую `reduce` из библиотеки.
6. **Проверка результата**:
   - Запускаю код и убеждаюсь, что общая сумма заказов и количество товаров вычеслены корректно. В примере, результат -
     2150 для суммы и 5 для количества товаров.

Данный подход эффективен для суммирования данных из сложных структур с помощью функции `reduce`.

### Sorted

#### Основные моменты лекции о функции сортировки `sorted`

1. **Знакомство с `sorted`**:
   - Функция `sorted` используется для сортировки любой итерируемой последовательности в Python.
   - Возвращает новый отсортированный список.
2. **Сортировка чисел**:
   - По умолчанию числа сортируются по значению (например, 5, 2, 9, 1 будут отсортированы как 1, 2, 5, 9).
   - Дополнительно можно указать параметр `reverse=True`, чтобы отсортировать в обратном порядке (напрример, от
     большего к меньшему).
3. **Сортировка строк**:
   - Строки сортируются по алфавиту.
   - Так же поддерживается обратная сортировка с помощью параметра `reverse`.
4. **Сортировка сложных структур (словари)**:
   - Для сортировки объектов типа словарей (например, пользоватлелей) необходимо указывать ключ для сортировки.
   - Используется параметр `key`, который может принимать функцию или лямбда-функцию для определения критерия
     сортировки, например, по возрасту.
5. **Многоуровневая сортировка**:
   - Возможно сортировка по нескольким критериям одновременно, например сначала по возрасту, потом по имени.
   - Для этого `key` возвращает кортеж значений, где кфждый элемент кортежа является отдельным критерием сортировки.
6. **Практическое применение**:
   - Такие сортировки позволяют гибко работать с данными, сортируя их по необходимым признакам, например, возрасту и
     имени.

Эти знания позволяют эффективно организовывать данные в вашем коде, и в слдующих упражнениях бвдет закреплена практика
применения сложных сортировок.

### Упражнение - Выплата зарплаты

В этом упражнении я рассмоьтрел работу функции `sorted` и предыдущими концепциями, изученными в модуле. Вот шаги,
которые я выполнил:

1. **Фильтрация активных сотрудников**:
   - Использовал `filter` с лямбда-функцией, чтобы оставить только тех сотрудников, у которых поле `active` равно
     `True`.
2. **Преобразование структуры данных**:
   - Применил `map` с лямбда-функцией, чтобы оставить только `name` и `salary` для каждого активного сотрудника, убрав
     департамент и статус активности.
3. **Сотрировка сотрудников**:
   - Использовал функцию `sorted` для сортировки сотрудников по убыванию `salary`. Для этого указал лямбда-функцию с
     отрицательным `salary`, чтобы ваполнять сортировку от большего к меньшему.
4. **Подсчет суммы зарплат**:
   - Применил функцию `reduce` для суммирования всех зарплат. Аккумулятор начинает с нуля, к которому добавляется
     `salary` каждого сотрудника.
5. **Вывод результатов**:
   - Вывел список сотрудников, отсортированных по зарплате, и общую сумму зарплат.

Этот последовательный подход помог лучше понять каждый этап обработки данных. Выполнив упражнение, я выделил активных
сотрудников, убрал лишние поля, отсортировал по зарплате и вычислил общую сумму выплаьт. Это удобнее делать поэтапно
для лучшей читабельности кода.

### Замыкание

#### Основные понятия

1. **Функции высшего порядка**: Функции, которые принимают другую функцию в качестве аргумента или возвращают функцию.
2. **Замыкание**: функция, которая "захватывает" переменные из своей внешней области видимости и сохраняет их
   состояние, даже когда внешняя функция завершила выполнение.

#### Пример 1: Создание фабрики функций

- **Outer функция**: создает внутреннюю функцию и возвращает ее.
- **Inner функция**: использует захваченные переменные из outer функции.

#### Пошаговая реализаци

1. Определение функции `outer`, внутри которой создается переменная `message` и функция `inner`.
2. `inner` возвращает значение `message`.
3. При вызове `outer`, возвращается `inner`.
4. Вызывая `inner`, можно получить доступ к `message`, даже после завершения `outer`.

#### Применение

- Создание фабрик функций: позволяет динамически создавать функции с заданным поведением.
- Пример с мультипликатором:
  - Функция `multiplier(factor)` возвращает функцию, умножающую входное значение `x` на `factor`.

#### Пример 2: Изменение состояния замыкания

- Использование `nonlocal` для изменения захваченной переменной в функции.
- Пример функции-счетчика `make_counter`:
  - Счетчик `count` увеличивается при каждом вызове `counter`.
  - `nonlocal` позволяет изменять `count` в замыкании.

## Раздел 12. Обработка ошибок

### Проект - Менеджер задач

На этом уроке я начинаю разработку финального проекта - консольного менеджера задач на Python. Вот основные моменты:

1. **Цели проекта**:
   - Создание консольного приложения для управления задачами.
   - Возможности: добавление, удаление, изменение задач, получение списка текущих задач, работа с тегами.
   - Задачи будут храниться в специальном хранилище, что позволит использовать проект как полноценный таск трекер.
2. **Структура проекта**:
   - Основная функция `main` будет обрабатывать пользователские команды.
   - Меню реализовано через бесконечный цикл `while True`, где обрабатываются команды: `help`, `add`, `remove`, `edit`
     и другие.
3. **Обработка команд**:
   - Команды могут содержать аргументы, разделенные пробелами.
   - Используется структура `match-case` для обработки команд.
   - Неизвестные команды сообщают об ошибке.
4. **Подготовка к началу разработки**:
   - Все старые данные очищаются, стартую с чистого файла `main.py`.
   - Основа готова для последующего наращивания функциональности, в следующем уроке узнаю об обработке ошибок.

Таким образом, заложена базовая стурктура приложения, которая позволит развивать более сложную функциональность в
последующих модулях.

### Try except

1. **Зачем обрабатывать ошибки**?
   - Обработка ошибок позволяет программе продолжать выполнение даже после возникновения ошибки.
   - Пример: Попытка преобразования строки в число с возможностью обработки ошибки.
2. **Конструкция try-except**:
   - Используется для обработки исключений в коде.
   - `try`: блок, в котором выполняется код, потенциально вызывающий исключения.
   - `except`: блок для обработки конкретных типов исключений. Например, `ValueError`.
3. **Обработка нескольких исключений**:
   - Можно использовать несколько блоков `except`, чтобы обрабатывать разные типы ошибко отдельно.
   - ПримерЖ Обработка `ValueError` и `ZeroDivisionError` в отном кодовом блоке.
4. **Дополнительные блоки**:
   - `else`: выполняется, если в блоке `try` не возникло исключений.
   - `finally`: выполняется всегда, независимо от наличия исключений. Полезно для действий, которые должны быть
     выполнены в любом случае, например, закрытие файла.
5. **Блок except для всех ошибок**:
   - Можно использовать `except Exception as e` для обработки всех исключений.
   - Однако, предпочтительно обрабатывать конкоретные ошибки, чтобы иметь возможность выполнять специфичную логику
     восстановления.
6. **Практическое применение**:
   - Код, который может вызвать ошибку, рекомендуется оборачивать в `try-except` для надежной обработки возможных
     исключений.

Заключение: обработка ошибок - важный навык, который делает ваши программы более надежными и устойчивыми.

### Упражнение - KeyboardInterrupt

На этом уроке я научился корректно обрабатывать выход из меню программы, чтобы избежать сбоев при нажании Ctrl-C, что
вызывает Keyborad Interrupt. Необходимо добавить обработку исключений (try-except) в наш цикл while.

1. Внутри цикла while добавляю блок try для оборачивания кода.
2. Использую except для обработки Keyboard Interrupt и вывожу сообщение о завершении приложения.
3. Добавляю еще один блок exept для обработки всех других исключений с выводом сообщений об ошибках.
4. Не забываю добавить break, чтобы корректно завершить работу программы после отлова исключения.

Таким образом, мое приложение теперь безопасно завершает работу при нажатии Ctrl-C и корректно обрабатывает другие
ошибки.

### Raise

#### Создание и Обработка Исключений в Python

1. **Обработка ошибок**:
   - Я научился обрабатывать ошибки, используя `try` и `except` блоки.
2. **Создание ошибок**:
   - Я могу с м выбрасывать (создавать) ошибки с помощью ключевого слова `raise`.
3. **Пример функции**:
   - Создам функцию `divide`, которая делит два числа `a` и `b`.
   - Если `b` равно 0, то выброшу ошибку `ZeroDivisionError`.
   - пример кода:
     ```
     def divide(a: float, b: float) -> float:
         if b == 0:
             raise ZeroDivisionError('Нельзя делить на ноль')
         return a / b
     ```
4. **Обработка выброшенной ошибки**:
   - Использую `try-exept`, чтобы поймать ошибку:
     ```
     try
         result = divide(10, 0)
     except ZeroDivisionError:
         print('Деление на ноль')
     ```
5. **Добавление костомного сообщения к ошибке**:
   - К `ZeroDivisionError` можно добавить текстовое сообшение или любой объенкт, чтобы лучше описать ошибку.
6. **Перебрасывание ошибок выше**:
   - Если необходимо передать ошибку на более высокий уровень, использую `raise` без аргументов внутри `except`.
   - Пример:
     ```
     try:
         calculate()
     except ZeroDivisionError:
         print('Поймали выше')
     ```
   - `calculate()` может использовать `try-except` и перебрасывать ошибку выше.
7. **Заключение**:
   - Я могу не только обрабатывать стандартные ошибки, но и создавать кастомные с описаниями.
   - `raise` позволяет передавать ошибки на разные уровни, обеспецивая гибкостьб в обработке исключений.

### Создание своих ошибок

#### Создание и Обработка Кастомных Ошибок в Python

1. **Проблема**: При проверке возраста в функции (`set_age`) возникат необходимость выбрасывать ошибку, если возраст
   невалиидный (меньше 0). Стандартные ошибки, такие как `ZeroDivisionError`, не дают ясного представления о проблеме.
2. **Решение**: Создание кастомной ошибки.
   - Определяю новый класс ошибки, наследуемый от `Exceptiion`.
   - Использую ключевое слово `class` для создания класса ошибки.
   - Пример:
   ```
   class InvalidAgeError(Exception):
       pass
   ```
3. **Применение**: Замена стандартного `raise` на кастомный.
   - Когда возникает ошибка (например, возраст отрицательный), использую
     `raise InvalidAgeError('Возраст должен быть больше 0')`.
4. **Обработка ошибки**:
   - Использую `try-except` блок для обработки нашей кастомной ошибки.

### Иерархия ошибок

В этой лекции рассматривается иерархия ошибок в программировании и их обработка. Вот основные моменты:

1. **Иерархия ошибок**:
   - На верхнем уровне находится BaseException - базовая ошибка, от которой наследуются более специфические ошибки.
   - Обзор подуровней включает Exception, от которого наследуются более конкретные ошибки, такие как ValueError,
     ZeroDivisionError и другие арифметические ошибки.
2. **Обработка ошибок**:
   - Исключения обрабатываются в порядке иерархии - от более конкретных к более общим.
   - Например, ZeroDivisionError является частным сучаем арифметической ошибки и наследуется от Exception.
3. **Пример обрабюотки**:
   - при попытке разделить 1 на 0, код сначала ищет соответствие ZeroDivisionError, затем арифметической ошибки и далее
     общей Exception, если первых двух обработчиков нет.
   - Если порядок обработки нарушен (например, общий Exception обработан раньше конкретного ZeroDivisionError), то
     всегда выполнится первый встреченный допустимый обработчик.
4. **Совместная обработка нескольких ошибок**:
   - В едином блоке исключений можно обработать несколько ошибок, указав их в кортеже, например, (ValueError,
     ZerroDivisionError).
5. **Создани кастомных ошибок**:
   - Разрабортчики могут создавать свои собственные ошибки, наследуясь от базовых ошибок, например, создание BankError
     от Exception, и далее специализированного ZeroFundError от BankError.

### Упражнение - Проверка корзины

##### Цель

- Реализовать функцию **checkout**, которая обрабатывает заказы в корзине.
- Обрабатывать возможные ошибки: пустая корзина, отсутствие товара на сладе и невалидный купон.

##### Шаги реализации

1. **Создание базвого класса ошибок**
   - Реализовать базовый класс `ShopError`, наследуемый от `Exception`.
   - Создать производные классы ошибок: `OutOfStockError`, `EmptyCartError`, `InvalidCouopError`, наследуемые от
     `ShopError`.
2. **Реализация функции Checkout**
   - Функция **checkout** принимает список товаров в корзине и купон.
   - Проверяет условия:
     - Если `cart` пустая, выдать ошибку `EmptyCartError`.
     - Для каждого продукта в `cart` проверить наличие на складе:
       - Если товар отсутствует, выдать ошибку `OutOfStockError`.
     - Вычислить общую стоимость товаров в коризне.
     - Проверить валидность купона:
       - Если купон не соответствует `sale20`, выдать `InvalidCouponError`.
   - Возвращает итоговую цену заказа, если все проверки пройдены.
3. **Обработка ошибок**
   - Обернуть вызов `checkout` в блок `try-except`.
   - Обработать конкретные ошибки:
     - `OutOfStockError` - выводит сообщение о недоступности товара.
     - `InvalidCouponError` - выводит сообщение о невалидности купона.
     - `EmptyCartError` - выводит сообщение о пустой корзине.
     - Общий `ShopError` - выводит сообщение о дргуих ошибках магазина.
4. **Тестирование и вывод результатов**
   - Протестировать функцию `checkout` на различных сценариях с выводом ошибок и волидного результата.

##### Результаты

- Реализация функции позволила обрабатывать основные ошибки, связанные с покупкой товаров в интернет-магазине.
- Программа корректно сообщает об ошибках пользователям при возникновении соответствующих условий.

## Раздел 13. Модули

### Что такое модуль

1. **Проблемы программирования в одном файле**:
   - **Усложнение поддержки**: если весь код приложения хранится в одном файле, его трудно читать и поддерживать.
   - **Отсутствие разделения ответственности**: весь функционал приложения сосредоточен в одном месте, что мешает
     структуре.
   - **Дублирование кода**: без модулей приходится копировать одинаковый код между разными частчями приложения.
2. **Приемущества модулей**:
   - **Разделение ответственности**: код структурируется по логическим частям, что облегчает его понимание и поддержку.
   - **Переиспользование кода**: одинаковые функции/модули можно использовать в разных проектах.
   - **Чистота и структура**: код разделен на отдельные файлы, каждый с ясной зоной ответственности.
3. **Работа с модулями**:
   - **Импортирование**: функционал модуля может быть импортирован и исполььзован в других частях приложения.
   - **Примеры импорта**: используя импорт, можно подключать как встроенные модули Python (например, `math`, `random`),
     так и собственные.
4. **Рекомендации по декомпозиции приложений**:
   - **По назначению**: отдельные утилиты для сохранения данных, рабооты с файлами и т.д.
   - **По функции**: например, модуль для работы с датами.
   - **По бизнес-сущностям**: разделение на важные бизнес-компоненты, такие как задачи в To-Do приложении или корзина в
     магазине.

### Импорт модулей

Импорт в Ptyhon: основные способы

1. Прямой импорт:
   - используется для получения доступа ко всем функциям и классам пакета;
   - пример: `import math`;
   - обращение к функции чепрез префикс пакета: `math.sqrt(16)`.
2. Импорт с алиасом:
   - позволяет сократить и упростить доступ к длинным названиям пакетов;
   - пример: `import math as m`;
   - обращение: `m.sqrt(16)`;
   - используется для удобства или станартизации, например, `import pandas as pd`.
3. Импорт конкретных функций:
   - импортирует только нужные функции или переменные;
   - пример: `from math import sqrt`;
   - прямое использование функции: `sqrt(16)`;
   - удобно для конкретных функций, но может приветсти к конфликтам имен.
4. Импорт нескольких функций:
   - импорт нескольких нужных элементов через запятую;
   - пример: `from math import sqrt, pi`;
   - используется, когда нужно несколько функций без полного импорта.
5. Импорт всех функций (\*):
   - использует синтаксис `from math import *`;
   - все функции доступны без префикса: `sqrt(16)`;
   - не рекомендуется из-за риска конфликтов имен и перезаписи встроенных функций.

Рекомендации:

- использовать прямой итмпорт для ясности и избежания конфликтов;
- с алиасами и выборочным импортом нужно быть осторожным, чтобы избежать путаницы.
- избегать wildcard-импорта (\*), чтобы сохранить читаемость и предсказуемость кода.

### Подключение своих модулей

В этом занятии я создал собственный Python-модуль и научился подключать его различными способами.

1. **Создание модуля**
   - Создал новый Python-файл `calc.py`.
   - Определил в нем функцию `add`, которая принимает два числа и возваращает х сумму.
   - В начале модуля добавил сторку документации для описания его функциональности, что является хорошей практикой.
2. **Импорт модуля**
   - В другом файле, например, `hello.py`, импортировал модуль `calc.py` с помощью стандар тного оператора `import`.
   - Использовал `calc.add` для вызова функции сложения.
3. **Особенности именования**
   - Избегайте конфликтов с названиями стандартных модулей Python.
   - Я могу испольовать алиас (псевдоним) для изменения имени модуля при импорте, например `import calc as sc`.
   - Импорт конкретных функций без префикса можно делатьс помощью `form calc import add`.
4. **Проверка работы**
   - Убедился в корректности выполнения операций, например, вызов `calc.add(1, 5), который вернул 6.

### Init py

На этом уроке обсуждается организация модулей в большом приложении с пспользованием простарнства имен. Основные
моменты:

1. **Проблема структуры**: в больших приложениях с множеством модулей хранение всех файлов в корне проекта
   неэффективно.
2. **Namespace модули**: решние заключается в группировке модулей в папки, которые выступают как пространства имен.
   Например, создать папку `utils` для утилитарных модулей и поместить туда модуль `calc`.
3. **Импорт модулей**: после перемещения модуля `calc` в `utils`, его можно импортировать с помощью `util.calc`. Если
   были вложенные папки, например, `adr`, импорт выглядел бы как `utils.adr.calc`.
4. **Поддержка в Python 3.3+**: с версии Python 3.3 и выше такие структуры поддерживаются автоматически. Для более
   старых версий нужно было создавать файл `__init__.py`, чтобы папка воспринималасьь как модуль.
5. **Функции `init.ph` в старых версиях**: раньше этот файл использовался для определения приватных свойств и группы
   модулей, но в современных версиях Python это не требуется.
6. **Рекомендации**: рекомендуется называть модули так, чтобы их функциональность была понятна из названия.

### Приватные методы

В этой лекции обсуждалось, как ограничить доступ к методам и классам внутри модулей в Python.

1. **Обозначение приватных методов**:
   - для обозначения методов и классов как приватных используется нижнее подчеркивание в их названиях, например,
     `_secret`;
   - такое обозначение сигнализирует другим разработчикам, что эти элементы не предназначены для использования за
     пределами модуля.
2. **Соглашение о приватности**:
   - хотя использование нижнего подчеркивания не предотвращает доступ программно, это устоявшееся соглашение среди
     разработчиков;
   - программисты понимают, что такие методы и классы являются внутренними и не должны итмпортироваться.
3. **Переменные `__all__` и `init.py`**:
   - переменная `__all__` служит для указания функций, которые должны быть доступны при импорте;
   - ранее `__init__.py` использовался для обозначения API, но на текущий момент его использование не так актуально для
     этого.

Заключение: для обозначения приватных методов и классов рекомендуется использовать нижнее подчеркивание. Это не только
упрощает понимание кода, но и следование этому соглашению помогает поддерживать поядок и ясность в проекте.

### Упражнение - Функция help

В этом упражнении рассмотрена задача создания команды Help для таск менеджера на Python. Цель - предоставить
пользователям список доступных команд и их описания. Краткое руководство:

1. **Создание модуля Help**:
   - создать модуль для обработки команд, влючая Help;
   - определить функцию (например, `help_command`), которая выводит список команд и их описание.
2. **Описание команд**:
   - примеры команд: `add` (добавление задачи), `list` (удаление задачи по ID), `tags` (управление тегами), `help`
     (вывод списка команд), `exit` (выход из программы).
3. **Импорт и использование**:
   - импортировать функцию `help_command` в основную программу;
   - обеспечить вывод помощи при вызове команды Help.

### Sys path

В этой лекции рассмотрено, как Python ищет модули для импорта.

1. **Импорт модулей**:
   - можем импортировать как стандартные, так и пользовательские модули;
   - вопрос в том, как Pythonрешает, где искать модули.
2. **Поиск модулей**:
   - Python использует список путей, хранящийся в `sys.path`;
   - включает:
     - **текущая директория проекта**: модули в этой директории доступны для импорта;
     - **стаднартная библиотека Python**: модули этой библиотеки также доступны.
3. **Просмотр доступных путей**:
   - можно вывести содержимое `sys.path` с помощью `print(sys.path)`.
4. **Добавление путей (хак)**:
   - `sys.path` - это список, и мы можем вручную добавить новый путь;
   - это работает только во время выполнения программы и являеется нежелательной практикой;
   - Visual Studio Code не распознает такие изменения.
5. **Рекомендации**:
   - не рекомендуется добавлять пути вручную;
   - создание своих модулей в проекте;
   - использование стандартных модулей или установка пакетов как внешних зависимостей;
   - об установке зависимостей будет рассказано в продвинутом курсе.

### Main name

#### Особенности испольнения Python модулей при импорте

1. **Исполнение кода при импорте**:
   - при импорте Python файл (модуль) исполняется, если содержит исполняемыый код. Например, `print()` будет выполнен.
2. **Проблемы с точкой входа**:
   - при смешивании исполняемого кода и компонентов, предназначенных для 0импорта, возникают трудности;
   - если исполняемый файл используется как модуль, хто может привести к нежелательному выполненияю кода.
3. **Использование `__name__` для предотвращения проблем**:
   - атрибут `__name__` модуля помогает определить, является ли файл точкой входа;
   - если файл запускается напрямую, `__name__` устанавливается в `__main__`.
4. **Улучшение кода с помощью проверки `__name__`**:
   - рекомендуется окружать исполняемый код проверкой
     ```
     if __name__ == '__main__':
       # Исполняемый код
     ```
   - это предотвращает нежелательное выполнение кода при импорте.
5. **Применение на практитке**:
   - созавая Python приложения, всегда используйте проверку `if __name__ == '__main__':` для кода, выполняющегося при
     запуске;
   - импортируемый код остается доступным без выполнения основной логики.

Использование `__name__` позволяет четка разделить роли файла: исполняемый или импортируемый как модуль, обеспечивая
гибкость и предотвращая ошибки.

### Типизация dict

1. **Описание Задачного Словаря**
   - Задача должна содержать:
     - идентификатор (id);
     - название (title);
     - приоритет (priority);
     - статус (status).
2. **Создание Структуры для Типизации**
   - Создание папки `types`.
   - Создание модуля `task.py` для работы с задачами.
3. **Типизация Задач с TypeDict**
   - Использую класс для типизации задач.
   - Наследую от `TypeDict` из библиотеки `Typing`.
   - Описание полей:
     - `id: int`;
     - `title: str`;
     - `priority: str`;
     - `status: str`.
4. **Приемущества типизации**
   - Обеспеченике ясности и упрощение поддержки кода.
   - Visual Studio Code (или аналог) сразу укажет на ошибки.
5. **Применение Типа `Task`**
   - Использование `Task` как типа данных для переменной `t`.
   - Упрощение разработки и тестирования функций, работающих с задачами.

### Упражнение - Создание задачи

В этом упражнении обсуждается создание функции `make_task` для создания задачи с различными параметрами. Вот основные
моменты:

1. **Цель упражнения**: создать функцию `make_task`, которая принимает следующие параметры:
   - `id`: идентификатор задачи (целое число);
   - `title`: название задачи (строка);
   - `priotity`: приоритет задачи (строка, со значением по умолчанию "medium");
   - `tegs`: список строк, по умолчанию пустой;
   - статус задачи задается по умолчанию как "new".
2. **Опциональные параметры**:
   - `tags`: опциональные теги, по умолчанию это пустой список.
3. **Реализация функции**:
   - функция принимает параметры и создает новый объект задачи типа Task;
   - задается валидация для параметра `priority`, допускаются 0только значения "low", "medium" или "high". Если другое
     значение, выбрасывается ошибка `ValueError`;
   - `title` очищается от пробелов с помощью метода `strip()`.
4. **Проблемы и решения**:
   - рассмотрено, как можно работать с параметрами по умолчанию и типизациями;
   - для списка `tags` был рассмотрен вариант с `None`, но в конечном счететвыбран пустой список, чтобы избежать
     сложностей с типизацией.
5. **Проверка работы**:
   - пример использования функции `make_task`, создав задачу и распечатав ее;
   - демонстрация обаботки неправильного приоритета с выбросом сообтетствующей ошибки.
6. **Дальнейшее действие**:
   - возможно, потребуется добавить обработку ошибок и валидацию в боолее сложных сценариях, например, с использованием
     цикла `while`.

Функция создает задачу и предоставляет механизм валидации входдных данных для обеспечения корректности созданной
задачи.

## Раздел 14. Дата и время

### Создание date и time

На этом уроке обсужадется работа с датой и временем в Python, что необходимо для создания функционального TaskManager.
Вот ключевые моменты:

1. **Импорт модуля**:
   - для работы с датой и временем используется пакет `datetime`; его нужно импортировать для дальнейших операций.
2. **Получение текущей даты и времени**:
   - с помощью `datetime.datetime.now()` можно получить текущую дату и время, включая миллисекунды;
   - для получения талько текущей даты используется метод `today()` из `datetime.date`.
3. **Работа с датой**:
   - можно создать произвольную дату, испльзуя `datetime.date()`, в которую передаются год, месяц и день;
   - доступны методы для получения информации, например `weekday()` для определения дня недели.
4. **Работа со временем**:
   - аналогично дате, можно создавать объект времени с помощью `datetime.time()` и указывать часы, минуты и секунды.
5. **Создание даты и времени вместе**:
   - комбинированный объект даты и времени создается при помощи `datetime.datetime()`, в который передаются параметры
     даты и времени.
6. **Дальнейшие возможности**:
   - созданные объекты даты и времени могут быть использованы для различных операций, таких ккак сравнение, изменение,
     расчет интервалов идругое, что пригодится в проекте TaskManager.

### Парсинг и форматирование

#### Форматирование даты

1. **Использование `strftime`**:
   - метод `strftime` помогает форматировать дату и время, используя специализированные символы;
   - примеры символов:
     - `%Y` - полный год (например, 2025);
     - `%y` - сокращенный год (например, 25);
     - `%m` - месяц (например, 12);
     - `%d` - день месяца (например, 05);
     - `%H` - час (например, 08);
     - `%M` - минута (например, 15);
     - `%S` - секунда (например, 57).
2. **Создание форматов**:
   - можно создавать формат, выводящий только дату: `%Y-%m-%d`;
   - возможна замена разделителей, например, на `/`.

#### Парсинг строки в дату

1. **Использование `strptime`**:
   - метод `strptime` преоббразует сторку в объект даты;
   - формат строки должен соответствовать ожидаемому формату, как и при форматировании.
2. **Обработка ошибок**:
   - если формат строки не совпадает с ожидаемым, возникает ошибка `ValueError`;
   - необходимо предуссмотреть обработку таких ошибок, чтобы программа могла корректно реагировать.

### Timedelta

На этом уроке обсуждалось, как работать с датами и производить различные математические операции, такие как вычитание и
сложение дат.

1. **Получение разницы между датами**:
   - для вычисления разницы создаю переменные с датами; например, меня интересует, сколько дней осталось до Нового
     года;
   - использую `datetime.date` для создания даты Нового года: `new_year = datetime.date(2026, 1, 1,)`;
   - получаю текущую дату через `datetime.date.today()`;
   - вычисляю разницу: `diference = new_year - today`;
   - из разницы можно извлечь количество дней: `defference.days`.
2. **Добавление или вычитание времени**:
   - использую `timedelta` из библиотеки `datetime` для манипуляций с датами;
   - чтобы узнать дату через определенное время, дообавляю `timedelta` к текущей дате; пример: для расчета даты через
     неделю: `next_week = today + timedelta(days=7)`;
   - `timedelta` позволяет задавать временные интервалы в днях, секундах, микросекундах и т.д.
3. **Пример вычитания**:
   - чтобы узнать дату месяц назад, можно вычесть `timedelta`: `last_month - today - timedelta(days=30)`.

Таким образом, `timedelta` позволяет легко вычислять даты на основе различных временных интервалов. Более того, он
полезен для вычисления разницы между двумя датами.

### Сравнение дат

В этой лекции рассматривается сравнение дат и времени в программировании. Основные моменты:

1. **Сравнение дат**:
   - даты могут быть сравнены с помощью стандартных операторов, таких как меньше, равно, неравно;
   - например, создаю две даты: D1 (17 сентября 2025) и D2 (31 декабря 2025);
   - проверяю, идет ли D1 раньше D2 через оператор "<"; в данном примере D1 действительно раньше D2 (True);
   - можно также проверить равенство и большее значение.
2. **Различие типов данных**:
   - важно, чтобы сравниваемые данные были одного типа; дата (Date) и дата-время (DateTime) не сравниваются напрямую;
   - ошибка TypeError возникает при попытке сравнения Date и DateTime без приведения их к единому типу;
   - то же правило касается времени (Time) и других типов.
3. **Практическое применение**:
   - сравнение дат и времени применяется для проверки дедлайнов;
   - пример: создаем текущую дату-время (now) и определяем дедлайн, после чего проверяем, успеваем ли мы к дедлайну с
     помощью сравнения now < дедлайн.
4. **Ключевой вывод**:
   - всегда приводите к одному типу перед сравнением: Date с Date, Time с Time, DateTime с DateTime;
   - это обеспечивает корректность и предсказуемость выполняемых логических операций.

Лекция помогает понять, как правильно и эффективно работать с временными данными в программных приложениях.

### Timezone

В этом уроке обсуждалась работа с таймзонами в Python, используя библиотеку `zoneinfo`, которая была добавлена с
версии 3.9. Мне пришлось ее добавить командой `pip install tzdata`. Уточню: работаю в операционной системе Windows 11.
Итак - основные моменты:

1. **Зачем нужны таймзоны**:
   - время разнится в зависимости от географического положения; например, когда в Москвве 17:00, в Нью-Йорке может быть
     10:00;
   - для приложений, где важно учитывать разные часовые пояса (например, планирование встреч), необходимо брать в
     расчет таймзоны.
2. **Использование библиотеки `zoneinfo`**:
   - для работы с тймзонами в Python 3.9+ используется библиотека `zoneinfo`;
     создание текущего времени в UTC:
     ```
     from zoneinfo import ZoneInfo
     from datetime import dateitime
     now_utc = datetime.now(ZoneInfo('UCT'))
     ```
   - получение времени в определенной таймзоне, напримпр, Нью-Йорк:
     ```
     now_ny = datetime.now(ZoneInfo(America/New_York'))
     ```
3. **Конвертация времени между таймзонами**:
   - планирование встречи:
     - если встреча назначена на 12:00 в Москве:
       ```
       meeting_time_moscow = datetime(2025, 12, 8, 12, 0, tzinfo=ZoneInfo('Europe/Moscow'))
       ```
     - для конвертации времени встречи в Нью-Йорк:
       ```
       meeting_time_ny = meeting_time_moscow.astimezine(ZoneInfo('America/New_York'))
       ```
4. **Практическое применение**:
   - таймзоны важно учитыввать в приложениях с различными часовыми поясами, напримпр, для планировщиков встреч;
   - если приложение используется в ограниченной географической области, можно ограничиться таймзоной компьютера
     польователя.

Работа с таймзонами важнжа для обеспечения корректности временных данных в приложениях, особенно в международных
проектах или системах с пользователями из разных регионов.

### Optional

В этой лекции я научился, как испрользовать тип Optional в программировании для улучшения типизации и удобства работы с
параметрами.

1. **Основы Optional**:
   - Optional позволяет передавать параметр, который может быть заданного типа или None, делая параметр необязательным;
   - это полезно, когда у меня нет данных или данные нужно обрабатывать позже.
2. **Пример использования**:
   - в моем приложении я могу использовать Optional для списка тегов, которые могут быть либо списком строк, либо None;
   - это равнозначно опциональному списку строк, позволяя обрабатвать отсутствие тегов более гибко.
3. **Преимущества типизации**:
   - благодаря Optional, мы можем создавать задачу без ошибок, даже если не указаны теги;
   - типизация помогает упростить работу с данными, предотвратить ошибки, например, при передаче неправильного типа
     данных, таких как строка вместо целого числа.
4. **Код на практике**:
   - Пример с фукнцией `make_task()`, которую можно выполнить с минимальным набором параметров, где теги могут
     отсутствовать;
   - это устраняет пустые списки в задачах, когда теги не заданы.

### Упражнение - Добавление даты

В этом упражнении я работал над улучшением структуры задачи (task) в моем проекте, добавляя поле для даты выполнения
(due date). Вот основные шаги:

1. **Задача**: добавить дату выполнения задачи, которая будет опициональной и может передаваться с задачей.
2. **Формат команды**: `add title приоритет дата теги`.
3. **Обновление класса Task**:
   - в класс Task добавляю новое поле `due`, которое будет представлять дату;
   - тип поля `due` будет `Optional[date]`, где `date` импортируется из `datetime`;
   - `due` может быть `None` по умолчанию, если дата не указана.
4. **Обновление функции**:
   - перемеенная `due` передается при создании обхекта задачи;
   - обработка и парсинг даты в задаче будут выполнены позже.

### Упражнение - Парсинг add

В этом упражнении я разобрался с парсингом команды `add` в контексте создания задачи. Вот основные шаги и задачи:

1. **Формат команды add**:
   - команда начинается с `add`;
   - за ней следует `title`;
   - потом приоритет (`priority`), который обязателен;
   - затем дата (`due`), которая является опциональной;
   - в конце идут теги(`tags`), если они есть.
2. **Структура парсинга**:
   - разбиваю команду и собираем аргументы в список `args`;
   - проверяю наличие аргументов, если их нет, выбрасываю ошибку `ValueError`.
3. **Парсинг аргументов**:
   - первый элемент `args` - это всегда `title`;
   - назначаю дефолтные значения для `priority`, `due` и `tags`;
   - прохожу каждый аргуент, начиная со второго, и:
     - если аргумент относится к приоритету, обновляю `priority`;
     - если это дата, пытаюсь конвертировать ее в объект `date` (с проверкой формата);
     - если это теги, разделяю их по запятой.
4. **Обработка ошибок**:
   - при парсинге даты может возникнуть ошибка - это отлавливается и выводится пояснение о неверном формате.
5. **Возврат данных**:
   - по окончании парсинга возвращаем кортеж из `title`, `priority`, `due` и `tags`.
6. **Имплементация команды**:
   - вызывается функция `parse_add` и создается задача из распарсенных данных;
   - команда тестируется на различных вариантах, чтобы убедиться в корректности работы.

### Цепочка исключений

1. **Цепочка ошибок**:
   - проблема: при обработке исключений мы можем потерять информацию об исходной ошибке, которая важна для диагностики;
   - решение: использование цепочек ошибок; вместо замены ошибки новой, сохраняем предыдущую в переменную (например,
     `e`) и пробрасываем ее вместе с новой;
   - результат: сохраняется полная информация об исходной ошибке, что облегчает диагностику.
2. **Парсинг аргументов**:
   - проблема: некорректный парсинг тайтла с несколькими словами, что приводет к ошибке в интерпретации аргументов;
   - решение: использовать библиотеку `shelex` для разбиения строк на аргументы, учитывая кавычки как группирующие
     элементы;
   - пример: теперь `"сделать кофе"`, будет восприниматься как одно целое назависимо от пробелов между словами;
   - результат: корректтная интепретация команд, где строки в кавычках считаются единым аргументом.

Эти улучшения делают код более удобным и надежным для пользователей и разработчиков. Теперь можно продолжать разработку
приложения с учетом этих улучшений.

## Раздел 15. Рабта с файловой системой

### Команда добавления

1. **Идентификаторы задач**:
   - введение переменной `next_id` для отслеживания идентификаторов задач;
   - идентификатор будет восстанавливаться по максимальному значению при сохранении, пока используется значение `1`.
2. **Структурирование кода**:
   - разделение логики команд и работы с задачами;
   - создание отдельного модуля `tasks` для работы с задачами;
   - описание самих команд в отдельном модуле `commands`.
3. **Реализация команды `add`**:
   - созданиие модуля `add.py` для добавления новых задач;
   - функция `add_command` принимает список задач, аргументы и `next_id`;
   - обработка аргументов происходит через `parse_args`;
   - создание задачи через `make_task` и добавление ее в список задач;
   - обработка ошибок через `try-except`.
4. **Интеграция команды `add` в `main.py`**:
   - использование новой команды `add_command` в `main.py`;
   - обновление `next_id` после успешного добавления задач.

### Упражнение - Вывод задачи

1. **Цель упражнения**: создать функцию для вывода данных в формате таблицы.
2. **Название функции**: `stringify_table` - функция будет находиться в модуле `helpers` и возвращать строку для
   печати.
3. **Импорт необходимых модулей**:
   - импортирую задачи: `from tasks import task`;
   - импортирую дату: `from datetime import date`.
4. **Создание заголовков** (headers): содержат катогории задачи - id, название, статус, приоритет, теги, дата
   выполнения.
5. **Формирование строк**:
   - для каждой задачи формируестя строка, состоящая из id, названия, статуса, приоритета, тегов и даты;
   - теги объединяются через запятую;
   - для даты происходит форматирование в "год-месяц-день".
6. **Вычисление ширины колонок**:
   - определяется максимальная длинна каждой колонки, сравнивая длину заголовка и данных.
7. **Форматирование вывода**:
   - создается функция дляя форматирования строк с учетом ширины колонок;
   - добавляются заголовки и данные с разделителями для формирования таблицы.
8. **Печать результирующей таблицы**:
   - объединяются все строки таблицы и выводятся на экран.

### Запись в файл

#### Запись в файл с помощью Python

**Открытие файла**

- **Функция `open`**: для открытия файла используется функция `open`, котормя принимает два основных аргумента:
  1. путь к файлу (например, `notes.txt`);
  2. режим работы с файлом.

**Режимы работы с файлами**

- **`r` (read)**: открытие файла только для чтения;
- **`w` (write)**: открытие файла для записи, затирает содержимое, если файл уже существует;
- **`a` (append)**: добавление информации в конец файла;
- **`x`**: создание нового файла, даст ошибку, если файл уже существует;
- дополнения:
  - `b`: работа с бинарными файлами;
  - `t`: работа с тектсовыми файлами (по умолчанию);
  - `+`: чтение и запись одновременно; например: - `r+`: чтение и запись (файл должен существовать); - `w+`: чтение и запись (очищает файл).

**Кодировка**

- **UTF-8**: современноя кодировка, поддерживающая широкий диапазон символов, включая эмодзи.

**Запись данных в файл**

- **Методы записи**:
  - `write`: записывает строку в файл;
  - `writelines`: записывает список строк в файл.

**Закрытие файла**

- **Важно**: всегда закрывайте файл после работы с ним, чтобы избежать утечек памяти и других нежелательных эффектов.

**Примеры**

- открытие и запись:
  ````
  with open('notes.txt', 'w', encoding='utf-8') as file:
      file.write('Первая сторка\n')
      file.write('Вторая строка\n')
  ```
  ````
- добавление информации:
  ````
  with poen('notes.txt', 'a', encoding='utf-8') as file:
      file.write('Третья строка\n')
  ```
  ````

**Итог**

Используйте правильные режимы икодировки, чтобы успешно манипулировать текстовыми файлами в Python, избегая потерь
данных и повышая производительность.

### With

В этом уроке мы рассмотрели важность корректного управления ресурсами, такимми как файлы, в программировании. Если файл
не закрыть после использования, это может приветси к утечке ресурсов и непредвиденным проблемам, особенно в сложных
циклах или в случаях повторного запроса доступа к файлу.

**Ключевые моменты**

1. **Утечки ресурсов**:
   - не закрытые файлы могут привести к утечке ресурсов;
   - это не всегда критично для простых программ, но в сложных системах может вызвать серьезные проблемы.
2. **Использованиее конструкции `with`**:
   - конструкция `with` управляет освоождением ресурсов автоматически;
   - с помощью `with` можно автоматизировать закрытие файлов после завершения работы с ними;
   - это делает код чище и устраняет необходимость вручную вызывать `fclose`.
3. **Преимущества конструкции `with`**:
   - позволяет избежать ошибок при закрытии файлов, особенно при наличии сложной логики;
   - сразу после выхода из блока `with` ресурс закрывается.
4. **Применение в коде**:
   - пример использования `with` с файлом:
     ```
     with open('notes.txt', mode='w', encoding='utf-8') as f:
         f.write('Привет\n')
     ```
     здесь файл автоматически закрывается после записи.
5. **Заключение**:
   - использование `with` - это лучший подход для работы с освобождаемиыми ресурсми, такими как файлы и HTTP-запросы.

В дальнейшем всегда используйте `with` для управления ресурсами, чтобы избежать утечек и упростить код.

### JSON

JSON, или JavaScript Object Notation, - это текстовый формат для предстввления структкрированных данных, широко
используемый для обмена данными между клиентом и сервером и их хранения, JSON представляется как набор кючей и
значений, аналогично словарям в Python: ключи заключаются в кавычки, а данные могут быть строками, числами, булевыми
значениями, объектоми (вложенными структурами) или массивами.

Структура JSON достаточно строга:

1. ключи в кавычках, знаачения строго типизированы;
2. каждый элемент отделен запятой, кроме последнего элемента на уровне;
3. JSON легко читается и пишется, благодаря своей простоте и логичности.

Ценность JSON заключается в его читабельности и простоте, что делает его стандартным выбором для большинства
приложений. Хотя в JSON не самый эффективный формат с точки зрения ресурсопотребления, чем, например, Protobuf, он
прост и удобен для большинства задач, где высокая производительность не критична.

### json dump

1. **json.dumps**:
   - преобразует объект Python в JSON-строку;
   - могут быть переданы дополнительные параметры (разделители, отступы);
   - пример: преобразую словарь с ключами "A" (значение `true`) и "B" (список `[1, 2, 3]`).
2. **json.dimp**:
   - записывает объект Python в файл в формате JSON;
   - использует метод `with open` для работы с файлами;
   - пример: создаю файл `task.json` и записываю в него словать с идентификкатором (`id: 1`) и
     заголовком (`title: 'задача').

#### Дополнительные параметры

- **ensuer_asscii**: при `False` кодировка UTF-8 поддерживается по умолчанию.
- **indent**: форматирует JSON с отступами, делая его более читабельным (наприер, 2 пробела).

#### Советы

- Используйте `dumps`, если нужно преобразовать объект в строку для передачи или отображения.
- Используйте `dump`, чтобы сохранить объект Python в файл.
- Параметр `indent` делает JSON более понятным, добавляя отступы.

### Упражнение - Сохранение JSON

Сегодня я сделал реализацию сохранения даных в JSON формате. Рассмотрю шаги, которые помогли мне сохранить задачи из
моего приложения.

1. **Формирование даты**: прямое сохранение даты в JSON не всегда оптимально, поэтому использую форматирование.
2. **Создание модуля**:
   - создал модуль `storage/file.py`;
   - импортировал библиотеку JSON для сериализации данных;
   - импортировал необходимые функции и данные, например, задачи (tasks).
3. **Реализация функции сохранения**:
   - объявил функцию `save_tasks`, принимающую путь для сохранения и сисок задач;
   - подготовил данные в виде словаря с ключом `tasks`;
   - открыл файл для записи с кодировкой UTF-8;
   - использовал `json.dump` для записи данных.
4. **Обработка исключений**:
   - убедился, ч о сохранение выполняется при завершении работы приложения или при возникновении исключений.
5. **Преобразование даты**:
   - использовал функцию `forman_date` для корректного преобразования даты задач;
   - если дата отсутствует, возвращается `None`.

### Чтение JSON

В этой лекции было рассмотрено, как работать с файлами в Python: как читать текстовые и JSON файлы.

1. **Чтение текстовых файлов**:
   - использую функцию `open` с параметрами: имя файла, режим чтения ('r'), и кодировку ('UTF-8');
   - для чтения файла целиком использую `f.read()`;
   - для посторочного чтения применяю цикл `for line in f`, где `line` - текущая строка;
   - чтобы вывести данные без лишних пробелов, использую метод `rstrip()`.
2. **Чтение JSON файлов**:
   - аналогично открываю файл с помощью `open`;
   - импортирую библиотеку `json`;
   - считываю данные методом `json.load()`, который преобразует JSON в пито-словарь или список;
   - вызываю и вывожу нужные атрибуты, например, `tasts` с идентификаторами, названиями, приоритетами и строками.

### Упражнение - Чтение задач

#### Цель упражнения

Создать функцию для загрузки задач из файла с обработкой двух типов ошибок:

- **FileNotFoundError**: возникает, когда файл не найден; в этом случае возвращается пустой список задач и начальный
  индекс;
- **JSONDecodeError**: возникает при невозможности преобразовать данные из файла в JSON; также возвращается пустой
  список задач.

#### Реализация функции `load_tasks`

1. **Подготовка и открытие файла**:
   - используется `try-except` блок для открытия файла через `with open()`, указывая путь к файлу, режим чтения и
     кодировку;
   - читаются данные с помощью `json.load()`.
2. **Обработка ошибок**:
   - исключение `FileNotFoundError`: возвращается пустой список и начальный индекс `1`;
   - исключение `JSONDecodeError`: выводится предупреждение о поврежденном JSON и возвращается пустой список и
     индекс `1`.
3. **Загрузка задач из файла**:
   - инициализируются переменные для хранения задач (`tasks`) и максимального идентификатора (`max_id`);
   - используется цикл для извлечения задач из JSON-структуры;
   - для каждой задачи извлекаются необходимые поля: `id`, `title`, `priority`, `tags`, `status`, `due` и прообразуются
     в нужный формат.
4. **Обработка исключений внутри цикла**:
   - пропускаются задачи, если случается ошибка в обработке данных.
5. **Возврат результата**:
   - возвращается список задач и следующий индекс.

#### Провека функции

- Импортируется и вызывается `load_tasks` с указанием пути к файлу.
- При успешной загрузке выполняются тесты на корректность.

### Упражнение - Команда list

#### Цель

Реализовать команду отображения списка задач с возможностью сортировки по приоритету или дате выполнения.

#### Создание нового модуля

1. Добавляется файл `list.py` в раздел команд.
2. Описывается команда `list_command`, которая принимает список задач и аргументы.

#### Парсинг аргументов

Создается функция `parse_list` для парсинга аргументов сортировки (`by`) по приоритету (`prio`) или дате (`due`).

#### Сортировка задач

1. Если `by` равен `prio`:
   - создается словать соответствия приоритетов (high: 0, medium: 1, low: 2);
   - сортируются задачи по приоритетам, используя это соответствие.
2. Если `by` равен `due`:
   - сортируются задачи по дате выполнления.

#### обработка пустого списка

Если список задач пуст, выводитя соответствующее сообщение.

#### Вывод результатов

При успешной сортировке выводятся задачи, используя `print(stringify_table)`.

#### Интерграция в проект

1. Подключается реализация в `main.py`.
2. Обрабатывается команда `list` для вызова `list_command`.

#### Тестирование

1. Проверка работы команды с различными вариантами входных данных.
2. Устранение найденных опечаток и ошибок.

Теперь моя команда `list` функциональна и позволяет сортировать задачи по указанным параметрам.

### Упражнение - Команда remove

В этой части курса я реализую функцию для удаления задачи из списка в Python.

#### Исправление ошибки

Обнаружена ошибка с `next_id`, из-за которой задачи создавались с одинаковым идентификатором. Исправлено, чтобы
корректно тестировать программу.

#### Реализация удаления задачи

1. **Создание нового модуля**:
   - создал файл `remove.py` для реализации функции удаления.
2. **Функция `remove_command`**:
   - принимает на вход список задач и аргументы;
   - пробую сконвертировать переданный идентификатор в число (`try-exept` для обработки ошибок).
3. **Реализация логики удаления**:
   - определяю функцию удаления задачи в основной программе;
   - сравниваю длину старого списка с новым после фильтрации, чтобы выяснить, была ли задача удалена.
4. **Обработка результатов**:
   - если задача удалена - возвращается `True` и выводится на экран подтверждение;
   - если задача не найдена - выводитсяч соответствующее сообщение.

### kwArgs

В этой лекции я рассмотрел использование kwArgs в Python для работы с функциями, которые могут принимать неграниченное
количество именованных аргументов.

#### Создание функции с kwArgs

1. Создается функция `update_task`, которая принимает обязательный параметр `task` и дополнительный набор аргументво
   `**kwargs`, которые будут передаваться в виде словаря.
2. Эти именованные аргументы позволяют передать, например, заголовок (title), приоритет (priority) и due date, которые
   будут автоматически упакованы в словарь `changes`.

#### обработка kwArgs

1. Внутрифункции я можу извлекать значения из словаря `changes` по ключам. Например, если передан `title`, его можно
   обновить, если проверка на пустоту прошла успешно.
2. Аналогично, я могу обрабатывать и другие параметры, такие как `priority`. Проверяется, соответствует ли он
   допустимым значениям (low, medium или high) и обновляется.

#### Проверка корректности данных

1. Вазно проверять, что переданные значения корректны. Например, если `title` пуст, выбрасывается ошибка `ValueError`.
2. Для `priority` также добавлена проверка на допустимые занчения с помощью условия `not in`.

#### Гибкость kwArgs

1. Использование `**kwargs` позволяет принимать любое количество дополнительных именованных аргументов, делая функцию
   гибкой и легко расширяемой.
2. Можно комбинировать `**kwargs` с обычными позиционными аргументами и `*args`.

### isinstance

#### Проверка изменений (changes)

Начинаю с проверки, существует ли ключ `due` в `changes`. Если нет - это значит, что обновлять дату не нужно.

#### Работа с переменной `due`

Извлекаю `due` в отдельну переменную для удобства.

#### Проверка значений

1. Если `due` существует, проверяю его значение.
2. `due` может быть либо `None` (для сброса даты), либо объектом типа `date`.
3. Для проверки типа используется функция `isinstance()`.

#### Обработка ошибок

1. Если `due` не `None` и не является экземпляром `date`, вызывается ошибка `TypeError`.
2. Сообщение об ошибке: поле `due` должно быть типа `date` или `None`.

#### Сужение типов

Устраняю неопределенность типа (unknown), чтобы корректно присвоить значение `due` объекту задачи.

#### Подведение итогов

1. После всех проверок обновляю поле `due` у задачи, если все условия выполнения корректны.
2. Готовлюсь к следующему этапу, где буду писать непосредственную команду для обновления задач.

### Упражнение - Команда edit

Для создания команды `edit` в системе управления задачами надо выполнить следующие шаги:

1. **Создание функции парсинга аргументов**:
   - реализовать функцию `parse_edit`, которая принимает список аргументов;
   - проверить, что переданы как минимум два аргумента (идентификатор и изменения);
   - пробовать преобразовать первый аргумент в идетификатор задачи, обработать ошибку преобразования;
   - собрать изменения в словать (это может быть изменение title, приоритера или даты).
2. **Создание команды редактирования**:
   - создать модуль `edit.py` с функцией `edit_command`;
   - импортировать функции и структуры для работы с задачами;
   - получить идентификатор и изменения задач с помощью `parse_edit`;
   - найти нужную задачу через филшьтр по идентификатору, орбработать слвчай, когда задача не найдена;
   - применить изменения к найденой задаче, используя функцию `update_task`.
3. **Интергация команды**:
   - интегрировать команду `edti` в основной модуль программы;
   - обработать взаимодействие с пользователем, вывод результатов редактирования задачи и ошибок.

### Next

1. **Функция next и итераторы**:
   - функция `next()` служит для получения следующего элемента из итератора;
   - итераторы можно создавать из обычных списков с помощью функции `iter()`.
2. **Применение функции next**:
   - использование `next()` для перемещения по элементам итератора;
   - возвращает следующий элемент, если он доступен, или занчение по умолчанию, если элементы закончились.
3. **Оптимизация поиска задач**:
   - вместо использования фильтрации можно использовать итераторы с `next()` для поиска задачи по ID;
   - создать функцию `find_task`, которая прринимает список задач и ID, и возвращает задачу или `None`.
4. **Реализация findTask**^
   - использовать итераторы длля создания потока задач с нужным ID;
   - получить первыйй подходящий элемент с помощью `next()`, применяя занчение по умолчанию `None`.
5. **Применение кода**:
   - вспомогательная функция `find_task` используется для оптимизации части кода, связанного с редактированием задач;
   - обновление логики проверки найденной задачи и работы с обновлением ее свойств, таких как статус и приоритет.

### Упражнение - Команда tags

В этой лекции я создал команду для управления тегами задач в отдельном модуле `tags.py`. Команда позволяет добавлять и
удалять теги для конкретных задач.

1. **Создание файла `tags.py`**:
   - добавляю описание: модуль для редактирования тегов.
2. **Проверка аргументов команды**:
   - если аргументов меньше трех, команда считается вызваннной неправильно;
   - аргументы включают: ID задачи, действие (`add` или `remove`) и сам тег.
3. **Обработка ID задачи**:
   - преобразую ID из аргумента в целое число;
   - если преобразование не удалось, выводится ошибка и завершаеься выполнение.
4. **Поиск задачи**:
   - использую функцию `find_task` для поиска задачи по ID;
   - если задача не найдена, выодится сообщение об ошибки и завершается выполнение.
5. **Добавление и удаление тегов**:
   - **Добавление (`add`)**:
      - проверяется наличие тега; если он отсутствует - добавляется;
      - если теги отсутствют, инициализируется пустые массивом перед добавлением;
   - **Удаление (`remove`)**:
      - используется `remove` метод для удаления тега;
      - если тега нет, обработка проходит без ошибок.
6. **Испльзование команды**:
   - импортирую команду и передаю ей список задач и аргументы;
   - пример команды на добавление `tags 2 add важно`;
   - пример команды на удаление `tags 3 remove важно`.
   
